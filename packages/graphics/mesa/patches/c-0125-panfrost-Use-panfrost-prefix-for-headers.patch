From 2b418e1bc8480f5943beb5a7304c15571fd34a92 Mon Sep 17 00:00:00 2001
From: Lyude Paul <thatslyude@gmail.com>
Date: Sun, 18 Nov 2018 18:32:33 -0500
Subject: [PATCH 125/151] panfrost: Use panfrost- prefix for headers

Since we're about to pull in all of ARM's official headers for their
kernel driver instead of our own, and all of those are prefixed with
mali-* or mali_*, let's rename ours to panfrost-* so there isn't any
confusion.

No functional changes.
---
 src/gallium/drivers/panfrost/include/mali-int.h    |   40 -
 src/gallium/drivers/panfrost/include/mali-ioctl.h  |  926 ---------------
 src/gallium/drivers/panfrost/include/mali-job.h    | 1173 --------------------
 .../drivers/panfrost/include/panfrost-int.h        |   40 +
 .../drivers/panfrost/include/panfrost-ioctl.h      |  926 +++++++++++++++
 .../drivers/panfrost/include/panfrost-job.h        | 1173 ++++++++++++++++++++
 src/gallium/drivers/panfrost/pan_blend_shaders.h   |    2 +-
 src/gallium/drivers/panfrost/pan_blending.h        |    2 +-
 src/gallium/drivers/panfrost/pan_nondrm.c          |    2 +-
 src/gallium/drivers/panfrost/pan_nondrm.h          |    4 +-
 .../drivers/panfrost/panwrap/panwrap-decoder.c     |    4 +-
 .../drivers/panfrost/panwrap/panwrap-decoder.h     |    4 +-
 .../drivers/panfrost/panwrap/panwrap-mmap.c        |    2 +-
 .../drivers/panfrost/panwrap/panwrap-mmap.h        |    2 +-
 .../drivers/panfrost/panwrap/panwrap-syscall.c     |    2 +-
 .../drivers/panfrost/panwrap/panwrap-util.h        |    2 +-
 16 files changed, 2152 insertions(+), 2152 deletions(-)
 delete mode 100644 src/gallium/drivers/panfrost/include/mali-int.h
 delete mode 100644 src/gallium/drivers/panfrost/include/mali-ioctl.h
 delete mode 100644 src/gallium/drivers/panfrost/include/mali-job.h
 create mode 100644 src/gallium/drivers/panfrost/include/panfrost-int.h
 create mode 100644 src/gallium/drivers/panfrost/include/panfrost-ioctl.h
 create mode 100644 src/gallium/drivers/panfrost/include/panfrost-job.h

diff --git a/src/gallium/drivers/panfrost/include/mali-int.h b/src/gallium/drivers/panfrost/include/mali-int.h
deleted file mode 100644
index 2c62b0b..0000000
--- a/src/gallium/drivers/panfrost/include/mali-int.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * © Copyright 2017-2018 The Panfrost Community
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- */
-
-#ifndef __MALI_INT_H_
-#define __MALI_INT_H_
-
-#include <inttypes.h>
-
-typedef uint8_t  u8;
-typedef uint16_t u16;
-typedef uint32_t u32;
-typedef uint64_t u64;
-
-typedef int8_t  s8;
-typedef int16_t s16;
-typedef int32_t s32;
-typedef int64_t s64;
-
-#endif
diff --git a/src/gallium/drivers/panfrost/include/mali-ioctl.h b/src/gallium/drivers/panfrost/include/mali-ioctl.h
deleted file mode 100644
index 4c13309..0000000
--- a/src/gallium/drivers/panfrost/include/mali-ioctl.h
+++ /dev/null
@@ -1,926 +0,0 @@
-/*
- * © Copyright 2008-2018 ARM Limited.
- * © Copyright 2017-2018 Lyude Paul
- * © Copyright 2017-2018 Alyssa Rosenzweig
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU license.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-/**
- * Definitions for all of the ioctls for the original open source Midgard/Bifrost GPU
- * kernel driver, written by ARM.
- */
-
-#ifndef __MALI_IOCTL_H__
-#define __MALI_IOCTL_H__
-
-#include "mali-int.h"
-
-#define MALI_GPU_NUM_TEXTURE_FEATURES_REGISTERS 3
-#define MALI_GPU_MAX_JOB_SLOTS 16
-#define MALI_MAX_COHERENT_GROUPS 16
-
-typedef u8 mali_atom_id;
-
-/**
- * Since these structs are passed to and from the kernel we need to make sure
- * that we get the size of each struct to match exactly what the kernel is
- * expecting. So, when editing this file make sure to add static asserts that
- * check each struct's size against the arg length you see in strace.
- */
-
-enum mali_ioctl_mem_flags {
-        /* IN */
-        MALI_MEM_PROT_CPU_RD = (1U << 0),      /**< Read access CPU side */
-        MALI_MEM_PROT_CPU_WR = (1U << 1),      /**< Write access CPU side */
-        MALI_MEM_PROT_GPU_RD = (1U << 2),      /**< Read access GPU side */
-        MALI_MEM_PROT_GPU_WR = (1U << 3),      /**< Write access GPU side */
-        MALI_MEM_PROT_GPU_EX = (1U << 4),      /**< Execute allowed on the GPU
-						    side */
-
-        MALI_MEM_GROW_ON_GPF = (1U << 9),      /**< Grow backing store on GPU
-						    Page Fault */
-
-        MALI_MEM_COHERENT_SYSTEM = (1U << 10), /**< Page coherence Outer
-						    shareable, if available */
-        MALI_MEM_COHERENT_LOCAL = (1U << 11),  /**< Page coherence Inner
-						    shareable */
-        MALI_MEM_CACHED_CPU = (1U << 12),      /**< Should be cached on the
-						    CPU */
-
-        /* IN/OUT */
-        MALI_MEM_SAME_VA = (1U << 13), /**< Must have same VA on both the GPU
-					    and the CPU */
-        /* OUT */
-        MALI_MEM_NEED_MMAP = (1U << 14), /**< Must call mmap to acquire a GPU
-					     address for the alloc */
-        /* IN */
-        MALI_MEM_COHERENT_SYSTEM_REQUIRED = (1U << 15), /**< Page coherence
-					     Outer shareable, required. */
-        MALI_MEM_SECURE = (1U << 16),          /**< Secure memory */
-        MALI_MEM_DONT_NEED = (1U << 17),       /**< Not needed physical
-						    memory */
-        MALI_MEM_IMPORT_SHARED = (1U << 18),   /**< Must use shared CPU/GPU zone
-						    (SAME_VA zone) but doesn't
-						    require the addresses to
-						    be the same */
-};
-
-#define MALI_IOCTL_MEM_FLAGS_IN_MASK                                          \
-	(MALI_MEM_PROT_CPU_RD | MALI_MEM_PROT_CPU_WR |                        \
-	 MALI_MEM_PROT_GPU_RD | MALI_MEM_PROT_GPU_WR | MALI_MEM_PROT_GPU_EX | \
-	 MALI_MEM_GROW_ON_GPF |                                               \
-	 MALI_MEM_COHERENT_SYSTEM | MALI_MEM_COHERENT_LOCAL |                 \
-	 MALI_MEM_CACHED_CPU |                                                \
-	 MALI_MEM_COHERENT_SYSTEM_REQUIRED | MALI_MEM_SECURE |                \
-	 MALI_MEM_DONT_NEED | MALI_MEM_IMPORT_SHARED)
-#define MALI_MEM_MAP_TRACKING_HANDLE (3ull << 12)
-
-enum mali_ioctl_coherency_mode {
-        COHERENCY_ACE_LITE = 0,
-        COHERENCY_ACE      = 1,
-        COHERENCY_NONE     = 31
-};
-
-/**
- * @brief Job dependency type.
- *
- * A flags field will be inserted into the atom structure to specify whether a
- * dependency is a data or ordering dependency (by putting it before/after
- * 'core_req' in the structure it should be possible to add without changing
- * the structure size).  When the flag is set for a particular dependency to
- * signal that it is an ordering only dependency then errors will not be
- * propagated.
- */
-typedef u8 mali_jd_dep_type;
-#define MALI_JD_DEP_TYPE_INVALID  (0)       /**< Invalid dependency */
-#define MALI_JD_DEP_TYPE_DATA     (1U << 0) /**< Data dependency */
-#define MALI_JD_DEP_TYPE_ORDER    (1U << 1) /**< Order dependency */
-
-/**
- * @brief Job chain hardware requirements.
- *
- * A job chain must specify what GPU features it needs to allow the
- * driver to schedule the job correctly.  By not specifying the
- * correct settings can/will cause an early job termination.  Multiple
- * values can be ORed together to specify multiple requirements.
- * Special case is ::MALI_JD_REQ_DEP, which is used to express complex
- * dependencies, and that doesn't execute anything on the hardware.
- */
-typedef u32 mali_jd_core_req;
-
-/* Requirements that come from the HW */
-
-/**
- * No requirement, dependency only
- */
-#define MALI_JD_REQ_DEP ((mali_jd_core_req)0)
-
-/**
- * Requires fragment shaders
- */
-#define MALI_JD_REQ_FS  ((mali_jd_core_req)1 << 0)
-
-/**
- * Requires compute shaders
- * This covers any of the following Midgard Job types:
- * - Vertex Shader Job
- * - Geometry Shader Job
- * - An actual Compute Shader Job
- *
- * Compare this with @ref MALI_JD_REQ_ONLY_COMPUTE, which specifies that the
- * job is specifically just the "Compute Shader" job type, and not the "Vertex
- * Shader" nor the "Geometry Shader" job type.
- */
-#define MALI_JD_REQ_CS  ((mali_jd_core_req)1 << 1)
-#define MALI_JD_REQ_T   ((mali_jd_core_req)1 << 2)   /**< Requires tiling */
-#define MALI_JD_REQ_CF  ((mali_jd_core_req)1 << 3)   /**< Requires cache flushes */
-#define MALI_JD_REQ_V   ((mali_jd_core_req)1 << 4)   /**< Requires value writeback */
-
-/* SW-only requirements - the HW does not expose these as part of the job slot
- * capabilities */
-
-/* Requires fragment job with AFBC encoding */
-#define MALI_JD_REQ_FS_AFBC  ((mali_jd_core_req)1 << 13)
-
-/**
- * SW-only requirement: coalesce completion events.
- * If this bit is set then completion of this atom will not cause an event to
- * be sent to userspace, whether successful or not; completion events will be
- * deferred until an atom completes which does not have this bit set.
- *
- * This bit may not be used in combination with MALI_JD_REQ_EXTERNAL_RESOURCES.
- */
-#define MALI_JD_REQ_EVENT_COALESCE ((mali_jd_core_req)1 << 5)
-
-/**
- * SW Only requirement: the job chain requires a coherent core group. We don't
- * mind which coherent core group is used.
- */
-#define MALI_JD_REQ_COHERENT_GROUP  ((mali_jd_core_req)1 << 6)
-
-/**
- * SW Only requirement: The performance counters should be enabled only when
- * they are needed, to reduce power consumption.
- */
-
-#define MALI_JD_REQ_PERMON               ((mali_jd_core_req)1 << 7)
-
-/**
- * SW Only requirement: External resources are referenced by this atom.  When
- * external resources are referenced no syncsets can be bundled with the atom
- * but should instead be part of a NULL jobs inserted into the dependency
- * tree.  The first pre_dep object must be configured for the external
- * resouces to use, the second pre_dep object can be used to create other
- * dependencies.
- *
- * This bit may not be used in combination with MALI_JD_REQ_EVENT_COALESCE.
- */
-#define MALI_JD_REQ_EXTERNAL_RESOURCES   ((mali_jd_core_req)1 << 8)
-
-/**
- * SW Only requirement: Software defined job. Jobs with this bit set will not
- * be submitted to the hardware but will cause some action to happen within
- * the driver
- */
-#define MALI_JD_REQ_SOFT_JOB        ((mali_jd_core_req)1 << 9)
-
-#define MALI_JD_REQ_SOFT_DUMP_CPU_GPU_TIME      (MALI_JD_REQ_SOFT_JOB | 0x1)
-#define MALI_JD_REQ_SOFT_FENCE_TRIGGER          (MALI_JD_REQ_SOFT_JOB | 0x2)
-#define MALI_JD_REQ_SOFT_FENCE_WAIT             (MALI_JD_REQ_SOFT_JOB | 0x3)
-
-/**
- * SW Only requirement : Replay job.
- *
- * If the preceding job fails, the replay job will cause the jobs specified in
- * the list of mali_jd_replay_payload pointed to by the jc pointer to be
- * replayed.
- *
- * A replay job will only cause jobs to be replayed up to MALIP_JD_REPLAY_LIMIT
- * times. If a job fails more than MALIP_JD_REPLAY_LIMIT times then the replay
- * job is failed, as well as any following dependencies.
- *
- * The replayed jobs will require a number of atom IDs. If there are not enough
- * free atom IDs then the replay job will fail.
- *
- * If the preceding job does not fail, then the replay job is returned as
- * completed.
- *
- * The replayed jobs will never be returned to userspace. The preceding failed
- * job will be returned to userspace as failed; the status of this job should
- * be ignored. Completion should be determined by the status of the replay soft
- * job.
- *
- * In order for the jobs to be replayed, the job headers will have to be
- * modified. The Status field will be reset to NOT_STARTED. If the Job Type
- * field indicates a Vertex Shader Job then it will be changed to Null Job.
- *
- * The replayed jobs have the following assumptions :
- *
- * - No external resources. Any required external resources will be held by the
- *   replay atom.
- * - Pre-dependencies are created based on job order.
- * - Atom numbers are automatically assigned.
- * - device_nr is set to 0. This is not relevant as
- *   MALI_JD_REQ_SPECIFIC_COHERENT_GROUP should not be set.
- * - Priority is inherited from the replay job.
- */
-#define MALI_JD_REQ_SOFT_REPLAY                 (MALI_JD_REQ_SOFT_JOB | 0x4)
-
-/**
- * HW Requirement: Requires Compute shaders (but not Vertex or Geometry Shaders)
- *
- * This indicates that the Job Chain contains Midgard Jobs of the 'Compute
- * Shaders' type.
- *
- * In contrast to @ref MALI_JD_REQ_CS, this does \b not indicate that the Job
- * Chain contains 'Geometry Shader' or 'Vertex Shader' jobs.
- */
-#define MALI_JD_REQ_ONLY_COMPUTE    ((mali_jd_core_req)1 << 10)
-
-/**
- * HW Requirement: Use the mali_jd_atom::device_nr field to specify a
- * particular core group
- *
- * If both @ref MALI_JD_REQ_COHERENT_GROUP and this flag are set, this flag
- * takes priority
- *
- * This is only guaranteed to work for @ref MALI_JD_REQ_ONLY_COMPUTE atoms.
- *
- * If the core availability policy is keeping the required core group turned
- * off, then the job will fail with a @ref MALI_JD_EVENT_PM_EVENT error code.
- */
-#define MALI_JD_REQ_SPECIFIC_COHERENT_GROUP ((mali_jd_core_req)1 << 11)
-
-/**
- * SW Flag: If this bit is set then the successful completion of this atom
- * will not cause an event to be sent to userspace
- */
-#define MALI_JD_REQ_EVENT_ONLY_ON_FAILURE   ((mali_jd_core_req)1 << 12)
-
-/**
- * SW Flag: If this bit is set then completion of this atom will not cause an
- * event to be sent to userspace, whether successful or not.
- */
-#define MALI_JD_REQ_EVENT_NEVER ((mali_jd_core_req)1 << 14)
-
-/**
- * SW Flag: Skip GPU cache clean and invalidation before starting a GPU job.
- *
- * If this bit is set then the GPU's cache will not be cleaned and invalidated
- * until a GPU job starts which does not have this bit set or a job completes
- * which does not have the @ref MALI_JD_REQ_SKIP_CACHE_END bit set. Do not use if
- * the CPU may have written to memory addressed by the job since the last job
- * without this bit set was submitted.
- */
-#define MALI_JD_REQ_SKIP_CACHE_START ((mali_jd_core_req)1 << 15)
-
-/**
- * SW Flag: Skip GPU cache clean and invalidation after a GPU job completes.
- *
- * If this bit is set then the GPU's cache will not be cleaned and invalidated
- * until a GPU job completes which does not have this bit set or a job starts
- * which does not have the @ref MALI_JD_REQ_SKIP_CACHE_START bti set. Do not
- * use if the CPU may read from or partially overwrite memory addressed by the
- * job before the next job without this bit set completes.
- */
-#define MALI_JD_REQ_SKIP_CACHE_END ((mali_jd_core_req)1 << 16)
-
-/**
- * These requirement bits are currently unused in mali_jd_core_req
- */
-#define MALIP_JD_REQ_RESERVED \
-	(~(MALI_JD_REQ_ATOM_TYPE | MALI_JD_REQ_EXTERNAL_RESOURCES | \
-	MALI_JD_REQ_EVENT_ONLY_ON_FAILURE | MALIP_JD_REQ_EVENT_NEVER | \
-	MALI_JD_REQ_EVENT_COALESCE | \
-	MALI_JD_REQ_COHERENT_GROUP | MALI_JD_REQ_SPECIFIC_COHERENT_GROUP | \
-	MALI_JD_REQ_FS_AFBC | MALI_JD_REQ_PERMON | \
-	MALI_JD_REQ_SKIP_CACHE_START | MALI_JD_REQ_SKIP_CACHE_END))
-
-/**
- * Mask of all bits in mali_jd_core_req that control the type of the atom.
- *
- * This allows dependency only atoms to have flags set
- */
-#define MALI_JD_REQ_ATOM_TYPE \
-	(MALI_JD_REQ_FS | MALI_JD_REQ_CS | MALI_JD_REQ_T | MALI_JD_REQ_CF | \
-	MALI_JD_REQ_V | MALI_JD_REQ_SOFT_JOB | MALI_JD_REQ_ONLY_COMPUTE)
-
-/**
- * Mask of all bits in mali_jd_core_req that control the type of a soft job.
- */
-#define MALI_JD_REQ_SOFT_JOB_TYPE (MALI_JD_REQ_SOFT_JOB | 0x1f)
-
-/*
- * Returns non-zero value if core requirements passed define a soft job or
- * a dependency only job.
- */
-#define MALI_JD_REQ_SOFT_JOB_OR_DEP(core_req) \
-	((core_req & MALI_JD_REQ_SOFT_JOB) || \
-	(core_req & MALI_JD_REQ_ATOM_TYPE) == MALI_JD_REQ_DEP)
-
-/**
- * @brief The payload for a replay job. This must be in GPU memory.
- */
-struct mali_jd_replay_payload {
-        /**
-         * Pointer to the first entry in the mali_jd_replay_jc list.  These
-         * will be replayed in @b reverse order (so that extra ones can be added
-         * to the head in future soft jobs without affecting this soft job)
-         */
-        u64 tiler_jc_list;
-
-        /**
-         * Pointer to the fragment job chain.
-         */
-        u64 fragment_jc;
-
-        /**
-         * Pointer to the tiler heap free FBD field to be modified.
-         */
-        u64 tiler_heap_free;
-
-        /**
-         * Hierarchy mask for the replayed fragment jobs. May be zero.
-         */
-        u16 fragment_hierarchy_mask;
-
-        /**
-         * Hierarchy mask for the replayed tiler jobs. May be zero.
-         */
-        u16 tiler_hierarchy_mask;
-
-        /**
-         * Default weight to be used for hierarchy levels not in the original
-         * mask.
-         */
-        u32 hierarchy_default_weight;
-
-        /**
-         * Core requirements for the tiler job chain
-         */
-        mali_jd_core_req tiler_core_req;
-
-        /**
-         * Core requirements for the fragment job chain
-         */
-        mali_jd_core_req fragment_core_req;
-};
-
-/**
- * @brief An entry in the linked list of job chains to be replayed. This must
- *        be in GPU memory.
- */
-struct mali_jd_replay_jc {
-        /**
-         * Pointer to next entry in the list. A setting of NULL indicates the
-         * end of the list.
-         */
-        u64 next;
-
-        /**
-         * Pointer to the job chain.
-         */
-        u64 jc;
-};
-
-/* Capabilities of a job slot as reported by JS_FEATURES registers */
-
-#define JS_FEATURE_NULL_JOB              (1u << 1)
-#define JS_FEATURE_SET_VALUE_JOB         (1u << 2)
-#define JS_FEATURE_CACHE_FLUSH_JOB       (1u << 3)
-#define JS_FEATURE_COMPUTE_JOB           (1u << 4)
-#define JS_FEATURE_VERTEX_JOB            (1u << 5)
-#define JS_FEATURE_GEOMETRY_JOB          (1u << 6)
-#define JS_FEATURE_TILER_JOB             (1u << 7)
-#define JS_FEATURE_FUSED_JOB             (1u << 8)
-#define JS_FEATURE_FRAGMENT_JOB          (1u << 9)
-
-struct mali_gpu_core_props {
-        /**
-         * Product specific value.
-         */
-        u32 product_id;
-
-        /**
-         * Status of the GPU release.
-         * No defined values, but starts at 0 and increases by one for each
-         * release status (alpha, beta, EAC, etc.).
-         * 4 bit values (0-15).
-         */
-        u16 version_status;
-
-        /**
-         * Minor release number of the GPU. "P" part of an "RnPn" release
-         * number.
-         * 8 bit values (0-255).
-         */
-        u16 minor_revision;
-
-        /**
-         * Major release number of the GPU. "R" part of an "RnPn" release
-         * number.
-         * 4 bit values (0-15).
-         */
-        u16 major_revision;
-
-        u16 : 16;
-
-        /**
-         * @usecase GPU clock speed is not specified in the Midgard
-         * Architecture, but is <b>necessary for OpenCL's clGetDeviceInfo()
-         * function</b>.
-         */
-        u32 gpu_speed_mhz;
-
-        /**
-         * @usecase GPU clock max/min speed is required for computing
-         * best/worst case in tasks as job scheduling ant irq_throttling. (It
-         * is not specified in the Midgard Architecture).
-         */
-        u32 gpu_freq_khz_max;
-        u32 gpu_freq_khz_min;
-
-        /**
-         * Size of the shader program counter, in bits.
-         */
-        u32 log2_program_counter_size;
-
-        /**
-         * TEXTURE_FEATURES_x registers, as exposed by the GPU. This is a
-         * bitpattern where a set bit indicates that the format is supported.
-         *
-         * Before using a texture format, it is recommended that the
-         * corresponding bit be checked.
-         */
-        u32 texture_features[MALI_GPU_NUM_TEXTURE_FEATURES_REGISTERS];
-
-        /**
-         * Theoretical maximum memory available to the GPU. It is unlikely
-         * that a client will be able to allocate all of this memory for their
-         * own purposes, but this at least provides an upper bound on the
-         * memory available to the GPU.
-         *
-         * This is required for OpenCL's clGetDeviceInfo() call when
-         * CL_DEVICE_GLOBAL_MEM_SIZE is requested, for OpenCL GPU devices. The
-         * client will not be expecting to allocate anywhere near this value.
-         */
-        u64 gpu_available_memory_size;
-};
-
-struct mali_gpu_l2_cache_props {
-        u8 log2_line_size;
-        u8 log2_cache_size;
-        u8 num_l2_slices; /* Number of L2C slices. 1 or higher */
-        u64 : 40;
-};
-
-struct mali_gpu_tiler_props {
-        u32 bin_size_bytes;	/* Max is 4*2^15 */
-        u32 max_active_levels;	/* Max is 2^15 */
-};
-
-struct mali_gpu_thread_props {
-        u32 max_threads;            /* Max. number of threads per core */
-        u32 max_workgroup_size;     /* Max. number of threads per workgroup */
-        u32 max_barrier_size;       /* Max. number of threads that can
-				       synchronize on a simple barrier */
-        u16 max_registers;          /* Total size [1..65535] of the register
-				       file available per core. */
-        u8  max_task_queue;         /* Max. tasks [1..255] which may be sent
-				       to a core before it becomes blocked. */
-        u8  max_thread_group_split; /* Max. allowed value [1..15] of the
-				       Thread Group Split field. */
-        enum {
-                MALI_GPU_IMPLEMENTATION_UNKNOWN = 0,
-                MALI_GPU_IMPLEMENTATION_SILICON = 1,
-                MALI_GPU_IMPLEMENTATION_FPGA    = 2,
-                MALI_GPU_IMPLEMENTATION_SW      = 3,
-        } impl_tech : 8;
-        u64 : 56;
-};
-
-/**
- * @brief descriptor for a coherent group
- *
- * \c core_mask exposes all cores in that coherent group, and \c num_cores
- * provides a cached population-count for that mask.
- *
- * @note Whilst all cores are exposed in the mask, not all may be available to
- * the application, depending on the Kernel Power policy.
- *
- * @note if u64s must be 8-byte aligned, then this structure has 32-bits of
- * wastage.
- */
-struct mali_ioctl_gpu_coherent_group {
-        u64 core_mask;	       /**< Core restriction mask required for the
-				 group */
-        u16 num_cores;	       /**< Number of cores in the group */
-        u64 : 48;
-};
-
-/**
- * @brief Coherency group information
- *
- * Note that the sizes of the members could be reduced. However, the \c group
- * member might be 8-byte aligned to ensure the u64 core_mask is 8-byte
- * aligned, thus leading to wastage if the other members sizes were reduced.
- *
- * The groups are sorted by core mask. The core masks are non-repeating and do
- * not intersect.
- */
-struct mali_gpu_coherent_group_info {
-        u32 num_groups;
-
-        /**
-         * Number of core groups (coherent or not) in the GPU. Equivalent to
-         * the number of L2 Caches.
-         *
-         * The GPU Counter dumping writes 2048 bytes per core group,
-         * regardless of whether the core groups are coherent or not. Hence
-         * this member is needed to calculate how much memory is required for
-         * dumping.
-         *
-         * @note Do not use it to work out how many valid elements are in the
-         * group[] member. Use num_groups instead.
-         */
-        u32 num_core_groups;
-
-        /**
-         * Coherency features of the memory, accessed by @ref gpu_mem_features
-         * methods
-         */
-        u32 coherency;
-
-        u32 : 32;
-
-        /**
-         * Descriptors of coherent groups
-         */
-        struct mali_ioctl_gpu_coherent_group group[MALI_MAX_COHERENT_GROUPS];
-};
-
-/**
- * A complete description of the GPU's Hardware Configuration Discovery
- * registers.
- *
- * The information is presented inefficiently for access. For frequent access,
- * the values should be better expressed in an unpacked form in the
- * base_gpu_props structure.
- *
- * @usecase The raw properties in @ref gpu_raw_gpu_props are necessary to
- * allow a user of the Mali Tools (e.g. PAT) to determine "Why is this device
- * behaving differently?". In this case, all information about the
- * configuration is potentially useful, but it <b>does not need to be processed
- * by the driver</b>. Instead, the raw registers can be processed by the Mali
- * Tools software on the host PC.
- *
- */
-struct mali_gpu_raw_props {
-        u64 shader_present;
-        u64 tiler_present;
-        u64 l2_present;
-        u64 stack_present;
-
-        u32 l2_features;
-        u32 suspend_size; /* API 8.2+ */
-        u32 mem_features;
-        u32 mmu_features;
-
-        u32 as_present;
-
-        u32 js_present;
-        u32 js_features[MALI_GPU_MAX_JOB_SLOTS];
-        u32 tiler_features;
-        u32 texture_features[3];
-
-        u32 gpu_id;
-
-        u32 thread_max_threads;
-        u32 thread_max_workgroup_size;
-        u32 thread_max_barrier_size;
-        u32 thread_features;
-
-        /*
-         * Note: This is the _selected_ coherency mode rather than the
-         * available modes as exposed in the coherency_features register.
-         */
-        u32 coherency_mode;
-};
-
-
-typedef u64 mali_ptr;
-
-#define MALI_PTR_FMT "0x%" PRIx64
-#define MALI_SHORT_PTR_FMT "0x%" PRIxPTR
-
-#ifdef __LP64__
-#define PAD_CPU_PTR(p) p
-#else
-#define PAD_CPU_PTR(p) p; u32 :32;
-#endif
-
-/* FIXME: Again, they don't specify any of these as packed structs. However,
- * looking at these structs I'm worried that there is already spots where the
- * compiler is potentially sticking in padding...
- * Going to try something a little crazy, and just hope that our compiler
- * happens to add the same kind of offsets since we can't really compare sizes
- */
-
-/*
- * Blob provided by the driver to store callback driver, not actually modified
- * by the driver itself
- */
-struct mali_jd_udata {
-        u64 blob[2];
-};
-
-struct mali_jd_dependency {
-        mali_atom_id  atom_id;               /**< An atom number */
-        mali_jd_dep_type dependency_type;    /**< Dependency type */
-};
-
-#define MALI_EXT_RES_MAX 10
-
-/* The original header never explicitly defines any values for these. In C,
- * this -should- expand to SHARED == 0 and EXCLUSIVE == 1, so the only flag we
- * actually need to decode here is EXCLUSIVE
- */
-enum mali_external_resource_access {
-        MALI_EXT_RES_ACCESS_SHARED,
-        MALI_EXT_RES_ACCESS_EXCLUSIVE,
-};
-
-/* An aligned address to the resource | mali_external_resource_access */
-typedef u64 mali_external_resource;
-
-struct mali_jd_atom_v2 {
-        mali_ptr jc;           /**< job-chain GPU address */
-        struct mali_jd_udata udata;	    /**< user data */
-        PAD_CPU_PTR(mali_external_resource *ext_res_list); /**< list of external resources */
-        u16 nr_ext_res;			    /**< nr of external resources */
-        u16 compat_core_req;	            /**< core requirements which
-					      correspond to the legacy support
-					      for UK 10.2 */
-        struct mali_jd_dependency pre_dep[2];  /**< pre-dependencies, one need to
-					      use SETTER function to assign
-					      this field, this is done in
-					      order to reduce possibility of
-					      improper assigment of a
-					      dependency field */
-        mali_atom_id atom_number;	    /**< unique number to identify the
-					      atom */
-        u8 prio;                  /**< Atom priority. Refer to @ref
-					      mali_jd_prio for more details */
-        u8 device_nr;			    /**< coregroup when
-					      BASE_JD_REQ_SPECIFIC_COHERENT_GROUP
-					      specified */
-        u8 : 8;
-        mali_jd_core_req core_req;          /**< core requirements */
-} __attribute__((packed));
-
-/**
- * enum mali_error - Mali error codes shared with userspace
- *
- * This is subset of those common Mali errors that can be returned to userspace.
- * Values of matching user and kernel space enumerators MUST be the same.
- * MALI_ERROR_NONE is guaranteed to be 0.
- *
- * @MALI_ERROR_NONE: Success
- * @MALI_ERROR_OUT_OF_GPU_MEMORY: Not used in the kernel driver
- * @MALI_ERROR_OUT_OF_MEMORY: Memory allocation failure
- * @MALI_ERROR_FUNCTION_FAILED: Generic error code
- */
-enum mali_error {
-        MALI_ERROR_NONE = 0,
-        MALI_ERROR_OUT_OF_GPU_MEMORY,
-        MALI_ERROR_OUT_OF_MEMORY,
-        MALI_ERROR_FUNCTION_FAILED,
-};
-
-/**
- * Header used by all ioctls
- */
-union mali_ioctl_header {
-        /* [in] The ID of the UK function being called */
-        u32 id : 32;
-        /* [out] The return value of the UK function that was called */
-        enum mali_error rc : 32;
-
-        u64 : 64;
-} __attribute__((packed));
-
-struct mali_ioctl_get_version {
-        union mali_ioctl_header header;
-        u16 major; /* [out] */
-        u16 minor; /* [out] */
-        u32 : 32;
-} __attribute__((packed));
-
-struct mali_ioctl_mem_alloc {
-        union mali_ioctl_header header;
-        /* [in] */
-        u64 va_pages;
-        u64 commit_pages;
-        u64 extent;
-        /* [in/out] */
-        u64 flags;
-        /* [out] */
-        mali_ptr gpu_va;
-        u16 va_alignment;
-
-        u32 : 32;
-        u16 : 16;
-} __attribute__((packed));
-
-struct mali_mem_import_user_buffer {
-        u64 ptr;
-        u64 length;
-};
-
-struct mali_ioctl_mem_import {
-        union mali_ioctl_header header;
-        /* [in] */
-        u64 phandle;
-        enum {
-                MALI_MEM_IMPORT_TYPE_INVALID = 0,
-                MALI_MEM_IMPORT_TYPE_UMP = 1,
-                MALI_MEM_IMPORT_TYPE_UMM = 2,
-                MALI_MEM_IMPORT_TYPE_USER_BUFFER = 3,
-        } type : 32;
-        u32 : 32;
-        /* [in/out] */
-        u64 flags;
-        /* [out] */
-        u64 gpu_va;
-        u64 va_pages;
-} __attribute__((packed));
-
-struct mali_ioctl_mem_commit {
-        union mali_ioctl_header header;
-        /* [in] */
-        mali_ptr gpu_addr;
-        u64 pages;
-        /* [out] */
-        u32 result_subcode;
-        u32 : 32;
-} __attribute__((packed));
-
-enum mali_ioctl_mem_query_type {
-        MALI_MEM_QUERY_COMMIT_SIZE = 1,
-        MALI_MEM_QUERY_VA_SIZE     = 2,
-        MALI_MEM_QUERY_FLAGS       = 3
-};
-
-struct mali_ioctl_mem_query {
-        union mali_ioctl_header header;
-        /* [in] */
-        mali_ptr gpu_addr;
-        enum mali_ioctl_mem_query_type query : 32;
-        u32 : 32;
-        /* [out] */
-        u64 value;
-} __attribute__((packed));
-
-struct mali_ioctl_mem_free {
-        union mali_ioctl_header header;
-        mali_ptr gpu_addr; /* [in] */
-} __attribute__((packed));
-/* FIXME: Size unconfirmed (haven't seen in a trace yet) */
-
-struct mali_ioctl_mem_flags_change {
-        union mali_ioctl_header header;
-        /* [in] */
-        mali_ptr gpu_va;
-        u64 flags;
-        u64 mask;
-} __attribute__((packed));
-/* FIXME: Size unconfirmed (haven't seen in a trace yet) */
-
-struct mali_ioctl_mem_alias {
-        union mali_ioctl_header header;
-        /* [in/out] */
-        u64 flags;
-        /* [in] */
-        u64 stride;
-        u64 nents;
-        u64 ai;
-        /* [out] */
-        mali_ptr gpu_va;
-        u64 va_pages;
-} __attribute__((packed));
-
-struct mali_ioctl_sync {
-        union mali_ioctl_header header;
-        mali_ptr handle;
-        PAD_CPU_PTR(void *user_addr);
-        u64 size;
-        enum {
-                MALI_SYNC_TO_DEVICE = 1,
-                MALI_SYNC_TO_CPU = 2,
-        } type : 8;
-        u64 : 56;
-} __attribute__((packed));
-
-struct mali_ioctl_gpu_props_reg_dump {
-        union mali_ioctl_header header;
-        struct mali_gpu_core_props core;
-        struct mali_gpu_l2_cache_props l2;
-        u64 : 64;
-        struct mali_gpu_tiler_props tiler;
-        struct mali_gpu_thread_props thread;
-
-        struct mali_gpu_raw_props raw;
-
-        /** This must be last member of the structure */
-        struct mali_gpu_coherent_group_info coherency_info;
-} __attribute__((packed));
-
-struct mali_ioctl_set_flags {
-        union mali_ioctl_header header;
-        u32 create_flags; /* [in] */
-        u32 : 32;
-} __attribute__((packed));
-
-struct mali_ioctl_stream_create {
-        union mali_ioctl_header header;
-        /* [in] */
-        char name[32];
-        /* [out] */
-        s32 fd;
-        u32 : 32;
-} __attribute__((packed));
-
-struct mali_ioctl_job_submit {
-        union mali_ioctl_header header;
-        /* [in] */
-        PAD_CPU_PTR(struct mali_jd_atom_v2 *addr);
-        u32 nr_atoms;
-        u32 stride;
-} __attribute__((packed));
-
-struct mali_ioctl_get_context_id {
-        union mali_ioctl_header header;
-        /* [out] */
-        s64 id;
-} __attribute__((packed));
-
-#undef PAD_PTR
-
-/* For ioctl's we haven't written decoding stuff for yet */
-typedef struct {
-        union mali_ioctl_header header;
-} __ioctl_placeholder;
-
-#define MALI_IOCTL_TYPE_BASE  0x80
-#define MALI_IOCTL_TYPE_MAX   0x82
-#define MALI_IOCTL_TYPE_COUNT (MALI_IOCTL_TYPE_MAX - MALI_IOCTL_TYPE_BASE + 1)
-
-#define MALI_IOCTL_GET_VERSION             (_IOWR(0x80,  0, struct mali_ioctl_get_version))
-#define MALI_IOCTL_MEM_ALLOC               (_IOWR(0x82,  0, struct mali_ioctl_mem_alloc))
-#define MALI_IOCTL_MEM_IMPORT              (_IOWR(0x82,  1, struct mali_ioctl_mem_import))
-#define MALI_IOCTL_MEM_COMMIT              (_IOWR(0x82,  2, struct mali_ioctl_mem_commit))
-#define MALI_IOCTL_MEM_QUERY               (_IOWR(0x82,  3, struct mali_ioctl_mem_query))
-#define MALI_IOCTL_MEM_FREE                (_IOWR(0x82,  4, struct mali_ioctl_mem_free))
-#define MALI_IOCTL_MEM_FLAGS_CHANGE        (_IOWR(0x82,  5, struct mali_ioctl_mem_flags_change))
-#define MALI_IOCTL_MEM_ALIAS               (_IOWR(0x82,  6, struct mali_ioctl_mem_alias))
-#define MALI_IOCTL_SYNC                    (_IOWR(0x82,  8, struct mali_ioctl_sync))
-#define MALI_IOCTL_POST_TERM               (_IOWR(0x82,  9, __ioctl_placeholder))
-#define MALI_IOCTL_HWCNT_SETUP             (_IOWR(0x82, 10, __ioctl_placeholder))
-#define MALI_IOCTL_HWCNT_DUMP              (_IOWR(0x82, 11, __ioctl_placeholder))
-#define MALI_IOCTL_HWCNT_CLEAR             (_IOWR(0x82, 12, __ioctl_placeholder))
-#define MALI_IOCTL_GPU_PROPS_REG_DUMP      (_IOWR(0x82, 14, struct mali_ioctl_gpu_props_reg_dump))
-#define MALI_IOCTL_FIND_CPU_OFFSET         (_IOWR(0x82, 15, __ioctl_placeholder))
-#define MALI_IOCTL_GET_VERSION_NEW         (_IOWR(0x82, 16, struct mali_ioctl_get_version))
-#define MALI_IOCTL_SET_FLAGS               (_IOWR(0x82, 18, struct mali_ioctl_set_flags))
-#define MALI_IOCTL_SET_TEST_DATA           (_IOWR(0x82, 19, __ioctl_placeholder))
-#define MALI_IOCTL_INJECT_ERROR            (_IOWR(0x82, 20, __ioctl_placeholder))
-#define MALI_IOCTL_MODEL_CONTROL           (_IOWR(0x82, 21, __ioctl_placeholder))
-#define MALI_IOCTL_KEEP_GPU_POWERED        (_IOWR(0x82, 22, __ioctl_placeholder))
-#define MALI_IOCTL_FENCE_VALIDATE          (_IOWR(0x82, 23, __ioctl_placeholder))
-#define MALI_IOCTL_STREAM_CREATE           (_IOWR(0x82, 24, struct mali_ioctl_stream_create))
-#define MALI_IOCTL_GET_PROFILING_CONTROLS  (_IOWR(0x82, 25, __ioctl_placeholder))
-#define MALI_IOCTL_SET_PROFILING_CONTROLS  (_IOWR(0x82, 26, __ioctl_placeholder))
-#define MALI_IOCTL_DEBUGFS_MEM_PROFILE_ADD (_IOWR(0x82, 27, __ioctl_placeholder))
-#define MALI_IOCTL_JOB_SUBMIT              (_IOWR(0x82, 28, struct mali_ioctl_job_submit))
-#define MALI_IOCTL_DISJOINT_QUERY          (_IOWR(0x82, 29, __ioctl_placeholder))
-#define MALI_IOCTL_GET_CONTEXT_ID          (_IOWR(0x82, 31, struct mali_ioctl_get_context_id))
-#define MALI_IOCTL_TLSTREAM_ACQUIRE_V10_4  (_IOWR(0x82, 32, __ioctl_placeholder))
-#define MALI_IOCTL_TLSTREAM_TEST           (_IOWR(0x82, 33, __ioctl_placeholder))
-#define MALI_IOCTL_TLSTREAM_STATS          (_IOWR(0x82, 34, __ioctl_placeholder))
-#define MALI_IOCTL_TLSTREAM_FLUSH          (_IOWR(0x82, 35, __ioctl_placeholder))
-#define MALI_IOCTL_HWCNT_READER_SETUP      (_IOWR(0x82, 36, __ioctl_placeholder))
-#define MALI_IOCTL_SET_PRFCNT_VALUES       (_IOWR(0x82, 37, __ioctl_placeholder))
-#define MALI_IOCTL_SOFT_EVENT_UPDATE       (_IOWR(0x82, 38, __ioctl_placeholder))
-#define MALI_IOCTL_MEM_JIT_INIT            (_IOWR(0x82, 39, __ioctl_placeholder))
-#define MALI_IOCTL_TLSTREAM_ACQUIRE        (_IOWR(0x82, 40, __ioctl_placeholder))
-
-#endif /* __MALI_IOCTL_H__ */
diff --git a/src/gallium/drivers/panfrost/include/mali-job.h b/src/gallium/drivers/panfrost/include/mali-job.h
deleted file mode 100644
index 0dab93c..0000000
--- a/src/gallium/drivers/panfrost/include/mali-job.h
+++ /dev/null
@@ -1,1173 +0,0 @@
-/*
- * © Copyright 2017-2018 Alyssa Rosenzweig
- * © Copyright 2017-2018 Connor Abbott
- * © Copyright 2017-2018 Lyude Paul
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- */
-
-#ifndef __MALI_JOB_H__
-#define __MALI_JOB_H__
-
-#include <mali-ioctl.h>
-
-#define T8XX
-
-#define MALI_SHORT_PTR_BITS (sizeof(uintptr_t)*8)
-
-#define MALI_FBD_HIERARCHY_WEIGHTS 8
-
-#define MALI_PAYLOAD_SIZE 256
-
-enum mali_job_type {
-        JOB_NOT_STARTED	= 0,
-        JOB_TYPE_NULL = 1,
-        JOB_TYPE_SET_VALUE = 2,
-        JOB_TYPE_CACHE_FLUSH = 3,
-        JOB_TYPE_COMPUTE = 4,
-        JOB_TYPE_VERTEX = 5,
-        JOB_TYPE_TILER = 7,
-        JOB_TYPE_FUSED = 8,
-        JOB_TYPE_FRAGMENT = 9,
-};
-
-enum mali_gl_mode {
-        MALI_GL_NONE           = 0x0,
-        MALI_GL_POINTS         = 0x1,
-        MALI_GL_LINES          = 0x2,
-        MALI_GL_LINE_STRIP     = 0x4,
-        MALI_GL_LINE_LOOP      = 0x6,
-        MALI_GL_TRIANGLES      = 0x8,
-        MALI_GL_TRIANGLE_STRIP = 0xA,
-        MALI_GL_TRIANGLE_FAN   = 0xC,
-};
-
-#define MALI_GL_CULL_FACE_BACK  0x80
-#define MALI_GL_CULL_FACE_FRONT 0x40
-
-#define MALI_GL_FRONT_FACE(v) (v << 5)
-#define MALI_GL_CCW (0)
-#define MALI_GL_CW  (1)
-
-/* TODO: Might this actually be a finer bitfield? */
-#define MALI_DEPTH_STENCIL_ENABLE 0x6400
-
-#define DS_ENABLE(field) \
-	(field == MALI_DEPTH_STENCIL_ENABLE) \
-	? "MALI_DEPTH_STENCIL_ENABLE" \
-	: (field == 0) ? "0" \
-	: "0 /* XXX: Unknown, check hexdump */"
-
-/* Used in stencil and depth tests */
-
-enum mali_func {
-        MALI_FUNC_NEVER    = 0,
-        MALI_FUNC_LESS     = 1,
-        MALI_FUNC_EQUAL    = 2,
-        MALI_FUNC_LEQUAL   = 3,
-        MALI_FUNC_GREATER  = 4,
-        MALI_FUNC_NOTEQUAL = 5,
-        MALI_FUNC_GEQUAL   = 6,
-        MALI_FUNC_ALWAYS   = 7
-};
-
-/* Same OpenGL, but mixed up. Why? Because forget me, that's why! */
-
-enum mali_alt_func {
-        MALI_ALT_FUNC_NEVER    = 0,
-        MALI_ALT_FUNC_GREATER  = 1,
-        MALI_ALT_FUNC_EQUAL    = 2,
-        MALI_ALT_FUNC_GEQUAL   = 3,
-        MALI_ALT_FUNC_LESS     = 4,
-        MALI_ALT_FUNC_NOTEQUAL = 5,
-        MALI_ALT_FUNC_LEQUAL   = 6,
-        MALI_ALT_FUNC_ALWAYS   = 7
-};
-
-/* Flags apply to unknown2_3? */
-
-#define MALI_HAS_MSAA		(1 << 0)
-#define MALI_CAN_DISCARD 	(1 << 5)
-
-/* Applies on T6XX, specifying that programmable blending is in use */
-#define MALI_HAS_BLEND_SHADER 	(1 << 6)
-
-/* func is mali_func */
-#define MALI_DEPTH_FUNC(func)	   (func << 8)
-#define MALI_GET_DEPTH_FUNC(flags) ((flags >> 8) & 0x7)
-#define MALI_DEPTH_FUNC_MASK	   MALI_DEPTH_FUNC(0x7)
-
-#define MALI_DEPTH_TEST		(1 << 11)
-
-/* Next flags to unknown2_4 */
-#define MALI_STENCIL_TEST      	(1 << 0)
-
-/* What?! */
-#define MALI_SAMPLE_ALPHA_TO_COVERAGE_NO_BLEND_SHADER (1 << 1)
-
-#define MALI_NO_DITHER		(1 << 9)
-#define MALI_DEPTH_RANGE_A	(1 << 12)
-#define MALI_DEPTH_RANGE_B	(1 << 13)
-#define MALI_NO_MSAA		(1 << 14)
-
-/* Stencil test state is all encoded in a single u32, just with a lot of
- * enums... */
-
-enum mali_stencil_op {
-        MALI_STENCIL_KEEP 	= 0,
-        MALI_STENCIL_REPLACE 	= 1,
-        MALI_STENCIL_ZERO 	= 2,
-        MALI_STENCIL_INVERT 	= 3,
-        MALI_STENCIL_INCR_WRAP 	= 4,
-        MALI_STENCIL_DECR_WRAP 	= 5,
-        MALI_STENCIL_INCR 	= 6,
-        MALI_STENCIL_DECR 	= 7
-};
-
-struct mali_stencil_test {
-        unsigned ref  			: 8;
-        unsigned mask 			: 8;
-        enum mali_func func 		: 3;
-        enum mali_stencil_op sfail 	: 3;
-        enum mali_stencil_op dpfail 	: 3;
-        enum mali_stencil_op dppass 	: 3;
-        unsigned zero			: 4;
-} __attribute__((packed));
-
-/* Blending is a mess, since anything fancy triggers a blend shader, and
- * -those- are not understood whatsover yet */
-
-#define MALI_MASK_R (1 << 0)
-#define MALI_MASK_G (1 << 1)
-#define MALI_MASK_B (1 << 2)
-#define MALI_MASK_A (1 << 3)
-
-enum mali_nondominant_mode {
-        MALI_BLEND_NON_MIRROR = 0,
-        MALI_BLEND_NON_ZERO = 1
-};
-
-enum mali_dominant_blend {
-        MALI_BLEND_DOM_SOURCE = 0,
-        MALI_BLEND_DOM_DESTINATION  = 1
-};
-
-enum mali_dominant_factor {
-        MALI_DOMINANT_UNK0 = 0,
-        MALI_DOMINANT_ZERO = 1,
-        MALI_DOMINANT_SRC_COLOR = 2,
-        MALI_DOMINANT_DST_COLOR = 3,
-        MALI_DOMINANT_UNK4 = 4,
-        MALI_DOMINANT_SRC_ALPHA = 5,
-        MALI_DOMINANT_DST_ALPHA = 6,
-        MALI_DOMINANT_CONSTANT = 7,
-};
-
-enum mali_blend_modifier {
-        MALI_BLEND_MOD_UNK0 = 0,
-        MALI_BLEND_MOD_NORMAL = 1,
-        MALI_BLEND_MOD_SOURCE_ONE = 2,
-        MALI_BLEND_MOD_DEST_ONE = 3,
-};
-
-struct mali_blend_mode {
-        enum mali_blend_modifier clip_modifier : 2;
-        unsigned unused_0 : 1;
-        unsigned negate_source : 1;
-
-        enum mali_dominant_blend dominant : 1;
-
-        enum mali_nondominant_mode nondominant_mode : 1;
-
-        unsigned unused_1 : 1;
-
-        unsigned negate_dest : 1;
-
-        enum mali_dominant_factor dominant_factor : 3;
-        unsigned complement_dominant : 1;
-} __attribute__((packed));
-
-struct mali_blend_equation {
-        /* Of type mali_blend_mode */
-        unsigned rgb_mode : 12;
-        unsigned alpha_mode : 12;
-
-        unsigned zero1 : 4;
-
-        /* Corresponds to MALI_MASK_* above and glColorMask arguments */
-
-        unsigned color_mask : 4;
-
-        /* Attached constant for CONSTANT_ALPHA, etc */
-
-#ifndef BIFROST
-        float constant;
-#endif
-} __attribute__((packed));
-
-/* Alpha coverage is encoded as 4-bits (from a clampf), with inversion
- * literally performing a bitwise invert. This function produces slightly wrong
- * results and I'm not sure why; some rounding issue I suppose... */
-
-#define MALI_ALPHA_COVERAGE(clampf) ((uint16_t) (int) (clampf * 15.0f))
-#define MALI_GET_ALPHA_COVERAGE(nibble) ((float) nibble / 15.0f)
-
-/* Applies to unknown1 */
-#define MALI_NO_ALPHA_TO_COVERAGE (1 << 10)
-
-struct mali_blend_meta {
-#ifdef T8XX
-        /* Base value of 0x200.
-         * OR with 0x1 for blending (anything other than REPLACE).
-         * OR with 0x2 for programmable blending
-         */
-
-        u64 unk1;
-
-        /* For programmable blending, these turn into the blend_shader address */
-        struct mali_blend_equation blend_equation_1;
-
-        u64 zero2;
-        struct mali_blend_equation blend_equation_2;
-#else
-        u32 unk1; // = 0x200
-        struct mali_blend_equation blend_equation;
-        /*
-         * - 0x19 normally
-         * - 0x3 when this slot is unused (everything else is 0 except the index)
-         * - 0x11 when this is the fourth slot (and it's used)
-         */
-        u16 unk2;
-        /* increments from 0 to 3 */
-        u16 index;
-        u32 unk3; // = 0x10ed688
-#endif
-} __attribute__((packed));
-
-struct mali_shader_meta {
-        mali_ptr shader;
-        u16 texture_count;
-        u16 sampler_count;
-        u16 attribute_count;
-        u16 varying_count;
-
-        union {
-                struct {
-                        u32 uniform_buffer_count : 4;
-                        u32 unk1 : 28; // = 0x800000 for vertex, 0x958020 for tiler
-                } bifrost1;
-                struct {
-                        /* 0x200 except MALI_NO_ALPHA_TO_COVERAGE. Mysterious 1
-                         * other times. Who knows really? */
-                        u16 unknown1;
-
-                        /* Whole number of uniform registers used, times two;
-                         * whole number of work registers used (no scale).
-                         */
-                        unsigned work_count : 5;
-                        unsigned uniform_count : 5;
-                        unsigned unknown2 : 6;
-                } midgard1;
-        };
-
-        /* On bifrost: Exactly the same as glPolygonOffset() for both.
-         * On midgard: Depth factor is exactly as passed to glPolygonOffset.
-         * Depth units is equal to the value passed to glDeptOhffset + 1.0f
-         * (use MALI_NEGATIVE)
-         */
-        float depth_units;
-        float depth_factor;
-
-        u32 unknown2_2;
-
-        u16 alpha_coverage;
-        u16 unknown2_3;
-
-        u8 stencil_mask_front;
-        u8 stencil_mask_back;
-        u16 unknown2_4;
-
-        struct mali_stencil_test stencil_front;
-        struct mali_stencil_test stencil_back;
-
-        union {
-                struct {
-                        u32 unk3 : 7;
-                        /* On Bifrost, some system values are preloaded in
-                         * registers R55-R62 by the thread dispatcher prior to
-                         * the start of shader execution. This is a bitfield
-                         * with one entry for each register saying which
-                         * registers need to be preloaded. Right now, the known
-                         * values are:
-                         *
-                         * Vertex/compute:
-                         * - R55 : gl_LocalInvocationID.xy
-                         * - R56 : gl_LocalInvocationID.z + unknown in high 16 bits
-                         * - R57 : gl_WorkGroupID.x
-                         * - R58 : gl_WorkGroupID.y
-                         * - R59 : gl_WorkGroupID.z
-                         * - R60 : gl_GlobalInvocationID.x
-                         * - R61 : gl_GlobalInvocationID.y/gl_VertexID (without base)
-                         * - R62 : gl_GlobalInvocationID.z/gl_InstanceID (without base)
-                         *
-                         * Fragment:
-                         * - R55 : unknown, never seen (but the bit for this is
-                         *   always set?)
-                         * - R56 : unknown (bit always unset)
-                         * - R57 : gl_PrimitiveID
-                         * - R58 : gl_FrontFacing in low bit, potentially other stuff
-                         * - R59 : u16 fragment coordinates (used to compute
-                         *   gl_FragCoord.xy, together with sample positions)
-                         * - R60 : gl_SampleMask (used in epilog, so pretty
-                         *   much always used, but the bit is always 0 -- is
-                         *   this just always pushed?)
-                         * - R61 : gl_SampleMaskIn and gl_SampleID, used by
-                         *   varying interpolation.
-                         * - R62 : unknown (bit always unset).
-                         */
-                        u32 preload_regs : 8;
-                        /* In units of 8 bytes or 64 bits, since the
-                         * uniform/const port loads 64 bits at a time.
-                         */
-                        u32 uniform_count : 7;
-                        u32 unk4 : 10; // = 2
-                } bifrost2;
-                struct {
-                        u32 unknown2_7;
-                } midgard2;
-        };
-
-        /* zero on bifrost */
-        u32 unknown2_8;
-
-        /* Blending information for the older non-MRT Midgard HW. Check for
-         * MALI_HAS_BLEND_SHADER to decide how to interpret.
-         */
-
-        union {
-                mali_ptr blend_shader;
-                struct mali_blend_equation blend_equation;
-        };
-
-        /* There can be up to 4 blend_meta's. None of them are required for
-         * vertex shaders or the non-MRT case for Midgard (so the blob doesn't
-         * allocate any space).
-         */
-        struct mali_blend_meta blend_meta[];
-
-} __attribute__((packed));
-
-/* This only concerns hardware jobs */
-
-/* Possible values for job_descriptor_size */
-
-#define MALI_JOB_32 0
-#define MALI_JOB_64 1
-
-struct mali_job_descriptor_header {
-        u32 exception_status;
-        u32 first_incomplete_task;
-        u64 fault_pointer;
-        u8 job_descriptor_size : 1;
-        enum mali_job_type job_type : 7;
-        u8 job_barrier : 1;
-        u8 unknown_flags : 7;
-        u16 job_index;
-        u16 job_dependency_index_1;
-        u16 job_dependency_index_2;
-
-        union {
-                u64 next_job_64;
-                u32 next_job_32;
-        };
-} __attribute__((packed));
-
-struct mali_payload_set_value {
-        u64 out;
-        u64 unknown;
-} __attribute__((packed));
-
-/* Special attributes have a fixed index */
-#define MALI_SPECIAL_ATTRIBUTE_BASE 16
-#define MALI_VERTEX_ID   (MALI_SPECIAL_ATTRIBUTE_BASE + 0)
-#define MALI_INSTANCE_ID (MALI_SPECIAL_ATTRIBUTE_BASE + 1)
-
-struct mali_attr {
-        mali_ptr elements;
-        u32 stride;
-        u32 size;
-} __attribute__((packed));
-
-/* TODO: I'm pretty sure this isn't really right in the presence of more
- * complicated metadata, like matrices or varyings */
-
-enum mali_attr_type {
-        MALI_ATYPE_PACKED = 1,
-        MALI_ATYPE_UNK1 = 1,
-        MALI_ATYPE_BYTE = 3,
-        MALI_ATYPE_SHORT = 4,
-        MALI_ATYPE_INT = 5,
-        MALI_ATYPE_GPVARYING = 6,
-        MALI_ATYPE_FLOAT = 7,
-};
-
-struct mali_attr_meta {
-        /* Vertex buffer index */
-        u8 index;
-
-        u64 unknown1 : 14;
-
-        /* Part of the type specifier, anyway:
-         * 1: packed (with other encoding weirdness)
-         * 3: byte
-         * 4: short
-         * 5: int
-         * 6: used for float gl_Position varying?
-         * 7: half, float, packed
-         */
-
-        unsigned type : 3;
-
-        /* After MALI_POSITIVE, 4 for vec4, 1 for scalar, etc */
-        unsigned nr_components : 2;
-
-        /* Somewhat correlated to the opposite of not_normalised, or the opposite of is_half_float? */
-        unsigned unknown2 : 1;
-
-        /* If the type is a signed integer, is_int_signed is set. If the type
-         * is a half-float, it's also set. Otherwise, it is clear. */
-
-        unsigned is_int_signed : 1;
-
-        /* if `normalized` passed to VertexAttribPointer is clear */
-        unsigned not_normalised : 1;
-
-        /* Always observed to be zero at the moment */
-        unsigned unknown3 : 2;
-
-        /* When packing multiple attributes in a buffer, offset addresses by this value */
-        uint32_t src_offset;
-} __attribute__((packed));
-
-enum mali_fbd_type {
-        MALI_SFBD = 0,
-        MALI_MFBD = 1,
-};
-
-#define FBD_TYPE (1)
-#define FBD_MASK (~0x3f)
-
-struct mali_uniform_buffer_meta {
-        /* This is actually the size minus 1 (MALI_POSITIVE), in units of 16
-         * bytes. This gives a maximum of 2^14 bytes, which just so happens to
-         * be the GL minimum-maximum for GL_MAX_UNIFORM_BLOCK_SIZE.
-         */
-        u64 size : 10;
-
-        /* This is missing the bottom 2 bits and top 8 bits. The top 8 bits
-         * should be 0 for userspace pointers, according to
-         * https://lwn.net/Articles/718895/. By reusing these bits, we can make
-         * each entry in the table only 64 bits.
-         */
-        mali_ptr ptr : 64 - 10;
-};
-
-/* On Bifrost, these fields are the same between the vertex and tiler payloads.
- * They also seem to be the same between Bifrost and Midgard. They're shared in
- * fused payloads.
- */
-
-/* Applies to unknown_draw */
-#define MALI_DRAW_INDEXED_UINT8  (0x10)
-#define MALI_DRAW_INDEXED_UINT16 (0x20)
-#define MALI_DRAW_INDEXED_UINT32 (0x30)
-
-struct mali_vertex_tiler_prefix {
-        /* This is a dynamic bitfield containing the following things in this order:
-         *
-         * - gl_WorkGroupSize.x
-         * - gl_WorkGroupSize.y
-         * - gl_WorkGroupSize.z
-         * - gl_NumWorkGroups.x
-         * - gl_NumWorkGroups.y
-         * - gl_NumWorkGroups.z
-         *
-         * The number of bits allocated for each number is based on the *_shift
-         * fields below. For example, workgroups_y_shift gives the bit that
-         * gl_NumWorkGroups.y starts at, and workgroups_z_shift gives the bit
-         * that gl_NumWorkGroups.z starts at (and therefore one after the bit
-         * that gl_NumWorkGroups.y ends at). The actual value for each gl_*
-         * value is one more than the stored value, since if any of the values
-         * are zero, then there would be no invocations (and hence no job). If
-         * there were 0 bits allocated to a given field, then it must be zero,
-         * and hence the real value is one.
-         *
-         * Vertex jobs reuse the same job dispatch mechanism as compute jobs,
-         * effectively doing glDispatchCompute(1, vertex_count, instance_count)
-         * where vertex count is the number of vertices.
-         */
-        u32 invocation_count;
-
-        u32 size_y_shift : 5;
-        u32 size_z_shift : 5;
-        u32 workgroups_x_shift : 6;
-        u32 workgroups_y_shift : 6;
-        u32 workgroups_z_shift : 6;
-        /* This is max(workgroups_x_shift, 2) in all the cases I've seen. */
-        u32 workgroups_x_shift_2 : 4;
-
-        u32 draw_mode : 4;
-        u32 unknown_draw : 22;
-
-        /* This is the the same as workgroups_x_shift_2 in compute shaders, but
-         * always 5 for vertex jobs and 6 for tiler jobs. I suspect this has
-         * something to do with how many quads get put in the same execution
-         * engine, which is a balance (you don't want to starve the engine, but
-         * you also want to distribute work evenly).
-         */
-        u32 workgroups_x_shift_3 : 6;
-
-
-        /* Negative of draw_start for TILER jobs from what I've seen */
-        int32_t negative_start;
-        u32 zero1;
-
-        /* Like many other strictly nonzero quantities, index_count is
-         * subtracted by one. For an indexed cube, this is equal to 35 = 6
-         * faces * 2 triangles/per face * 3 vertices/per triangle - 1. For
-         * non-indexed draws, equal to vertex_count. */
-
-        u32 index_count;
-
-        /* No hidden structure; literally just a pointer to an array of
-         * uint32_t indices. Thanks, guys, for not making my life insane for
-         * once! NULL for non-indexed draws. */
-
-        uintptr_t indices;
-} __attribute__((packed));
-
-struct bifrost_vertex_only {
-        u32 unk2; /* =0x2 */
-
-        u32 zero0;
-
-        u64 zero1;
-} __attribute__((packed));
-
-struct bifrost_tiler_heap_meta {
-        u32 zero;
-        u32 heap_size;
-        /* note: these are just guesses! */
-        mali_ptr tiler_heap_start;
-        mali_ptr tiler_heap_free;
-        mali_ptr tiler_heap_end;
-
-        /* hierarchy weights? but they're still 0 after the job has run... */
-        u32 zeros[12];
-} __attribute__((packed));
-
-struct bifrost_tiler_meta {
-        u64 zero0;
-        u32 unk; // = 0xf0
-        u16 width;
-        u16 height;
-        u64 zero1;
-        mali_ptr tiler_heap_meta;
-        /* TODO what is this used for? */
-        u64 zeros[20];
-} __attribute__((packed));
-
-struct bifrost_tiler_only {
-        /* 0x20 */
-        float line_width;
-        u32 zero0;
-
-        mali_ptr tiler_meta;
-
-        u64 zero1, zero2, zero3, zero4, zero5, zero6;
-
-        u32 gl_enables;
-        u32 zero7;
-        u64 zero8;
-} __attribute__((packed));
-
-struct bifrost_scratchpad {
-        u32 zero;
-        u32 flags; // = 0x1f
-        /* This is a pointer to a CPU-inaccessible buffer, 16 pages, allocated
-         * during startup. It seems to serve the same purpose as the
-         * gpu_scratchpad in the SFBD for Midgard, although it's slightly
-         * larger.
-         */
-        mali_ptr gpu_scratchpad;
-} __attribute__((packed));
-
-struct mali_vertex_tiler_postfix {
-        /* Zero for vertex jobs. Pointer to the position (gl_Position) varying
-         * output from the vertex shader for tiler jobs.
-         */
-
-        uintptr_t position_varying;
-
-        /* An array of mali_uniform_buffer_meta's. The size is given by the
-         * shader_meta.
-         */
-        uintptr_t uniform_buffers;
-
-        /* For reasons I don't quite understand this is a pointer to a pointer.
-         * That second pointer points to the actual texture descriptor. */
-        uintptr_t texture_trampoline;
-
-        /* For OpenGL, from what I've seen, this is intimately connected to
-         * texture_meta. cwabbott says this is not the case under Vulkan, hence
-         * why this field is seperate (Midgard is Vulkan capable) */
-        uintptr_t sampler_descriptor;
-
-        uintptr_t uniforms;
-        u8 flags : 4;
-uintptr_t _shader_upper :
-        MALI_SHORT_PTR_BITS - 4; /* struct shader_meta */
-        uintptr_t attributes; /* struct attribute_buffer[] */
-        uintptr_t attribute_meta; /* attribute_meta[] */
-        uintptr_t varyings; /* struct attr */
-        uintptr_t varying_meta; /* pointer */
-        uintptr_t viewport;
-        uintptr_t zero6;
-
-        /* Note: on Bifrost, this isn't actually the FBD. It points to
-         * bifrost_scratchpad instead. However, it does point to the same thing
-         * in vertex and tiler jobs.
-         */
-        mali_ptr framebuffer;
-
-#if UINTPTR_MAX == 0xffffffffffffffff /* 64-bit */
-#ifndef T8XX
-        /* most likely padding to make this a multiple of 64 bytes */
-        u64 zero7;
-#endif
-#endif
-} __attribute__((packed));
-
-struct midgard_payload_vertex_tiler {
-#ifdef T6XX
-        float line_width;
-#endif
-
-        struct mali_vertex_tiler_prefix prefix;
-
-#ifdef T6XX
-        u32 zero3;
-#endif
-        u32 gl_enables; // 0x5
-
-        /* Offset for first vertex in buffer */
-        u32 draw_start;
-
-#ifdef T6XX
-        u32 zero5;
-#else
-        u64 zero5;
-#endif
-
-        struct mali_vertex_tiler_postfix postfix;
-
-#ifdef T8XX
-        float line_width;
-#endif
-} __attribute__((packed));
-
-struct bifrost_payload_vertex {
-        struct mali_vertex_tiler_prefix prefix;
-        struct bifrost_vertex_only vertex;
-        struct mali_vertex_tiler_postfix postfix;
-} __attribute__((packed));
-
-struct bifrost_payload_tiler {
-        struct mali_vertex_tiler_prefix prefix;
-        struct bifrost_tiler_only tiler;
-        struct mali_vertex_tiler_postfix postfix;
-} __attribute__((packed));
-
-struct bifrost_payload_fused {
-        struct mali_vertex_tiler_prefix prefix;
-        struct bifrost_tiler_only tiler;
-        struct mali_vertex_tiler_postfix tiler_postfix;
-        struct bifrost_vertex_only vertex;
-        struct mali_vertex_tiler_postfix vertex_postfix;
-} __attribute__((packed));
-
-/* Pointed to from texture_trampoline, mostly unknown still, haven't
- * managed to replay successfully */
-
-/* Purposeful off-by-one in width, height fields. For example, a (64, 64)
- * texture is stored as (63, 63) in these fields. This adjusts for that.
- * There's an identical pattern in the framebuffer descriptor. Even vertex
- * count fields work this way, hence the generic name -- integral fields that
- * are strictly positive generally need this adjustment. */
-
-#define MALI_POSITIVE(dim) (dim - 1)
-
-/* Opposite of MALI_POSITIVE, found in the depth_units field */
-
-#define MALI_NEGATIVE(dim) (dim + 1)
-
-/* Used with channel swizzling */
-enum mali_channel {
-        MALI_CHANNEL_RED = 0,
-        MALI_CHANNEL_GREEN = 1,
-        MALI_CHANNEL_BLUE = 2,
-        MALI_CHANNEL_ALPHA = 3,
-        MALI_CHANNEL_ZERO = 4,
-        MALI_CHANNEL_ONE = 5,
-        MALI_CHANNEL_RESERVED_0 = 6,
-        MALI_CHANNEL_RESERVED_1 = 7,
-};
-
-/* Used with wrapping. Incomplete (this is a 4-bit field...) */
-
-enum mali_wrap_mode {
-        MALI_WRAP_REPEAT = 0x8,
-        MALI_WRAP_CLAMP_TO_EDGE = 0x9,
-        MALI_WRAP_CLAMP_TO_BORDER = 0xB,
-        MALI_WRAP_MIRRORED_REPEAT = 0xC
-};
-
-/* 8192x8192 */
-#define MAX_MIP_LEVELS (13)
-
-/* Cubemap bloats everything up */
-#define MAX_FACES (6)
-
-/* Corresponds to the type passed to glTexImage2D and so forth */
-
-struct mali_texture_format {
-        unsigned bottom : 8;
-        unsigned unk1 : 4;
-
-        /*
-         * 0: ushort_5_6_5
-         * 2: ushort_4_4_4_4
-         * 3: u8
-         * 4: u16
-         * 5: u32
-         * 7: float
-         */
-
-        unsigned component_size : 3;
-
-        unsigned nr_channels : 2;
-
-        /*
-         * 2: ushort_5_5_5_1, ushort_5_6_5
-         * 3: snorm
-         * 4: unsigned int
-         * 5: (unsigned) int / full-float
-         * 6: signed int / half-float
-         * 7: maybe also snorm related
-         */
-
-        unsigned typeA : 3;
-
-        unsigned usage1 : 3;
-        unsigned is_not_cubemap : 1;
-        unsigned usage2 : 8;
-} __attribute__((packed));
-
-struct mali_texture_descriptor {
-        uint16_t width;
-        uint16_t height;
-        uint16_t depth;
-
-        uint16_t unknown1;
-
-        struct mali_texture_format format;
-
-        uint16_t unknown3;
-
-        /* One for non-mipmapped, zero for mipmapped */
-        uint8_t unknown3A;
-
-        /* Zero for non-mipmapped, (number of levels - 1) for mipmapped */
-        uint8_t nr_mipmap_levels;
-
-        /* Swizzling is a single 32-bit word, broken up here for convenience.
-         * Here, swizzling refers to the ES 3.0 texture parameters for channel
-         * level swizzling, not the internal pixel-level swizzling which is
-         * below OpenGL's reach */
-
-        enum mali_channel swizzle_r : 3;
-        enum mali_channel swizzle_g : 3;
-        enum mali_channel swizzle_b : 3;
-        enum mali_channel swizzle_a : 3;
-        unsigned swizzle_zero       : 20;
-
-        uint32_t unknown5;
-        uint32_t unknown6;
-        uint32_t unknown7;
-
-        mali_ptr swizzled_bitmaps[MAX_MIP_LEVELS * MAX_FACES];
-} __attribute__((packed));
-
-/* Used as part of filter_mode */
-
-#define MALI_GL_LINEAR 0
-#define MALI_GL_NEAREST 1
-#define MALI_GL_MIP_LINEAR (0x18)
-
-/* Used to construct low bits of filter_mode */
-
-#define MALI_GL_TEX_MAG(mode) (((mode) & 1) << 0)
-#define MALI_GL_TEX_MIN(mode) (((mode) & 1) << 1)
-
-#define MALI_GL_TEX_MAG_MASK (1)
-#define MALI_GL_TEX_MIN_MASK (2)
-
-#define MALI_FILTER_NAME(filter) (filter ? "MALI_GL_NEAREST" : "MALI_GL_LINEAR")
-
-/* Used for lod encoding. Thanks @urjaman for pointing out these routines can
- * be cleaned up a lot. */
-
-#define DECODE_FIXED_16(x) ((float) (x / 256.0))
-
-static inline uint16_t
-FIXED_16(float x)
-{
-        /* Clamp inputs, accounting for float error */
-        float max_lod = (32.0 - (1.0 / 512.0));
-
-        x = ((x > max_lod) ? max_lod : ((x < 0.0) ? 0.0 : x));
-
-        return (int) (x * 256.0);
-}
-
-struct mali_sampler_descriptor {
-        uint32_t filter_mode;
-
-        /* Fixed point. Upper 8-bits is before the decimal point, although it
-         * caps [0-31]. Lower 8-bits is after the decimal point: int(round(x *
-         * 256)) */
-
-        uint16_t min_lod;
-        uint16_t max_lod;
-
-        /* All one word in reality, but packed a bit */
-
-        enum mali_wrap_mode wrap_s : 4;
-        enum mali_wrap_mode wrap_t : 4;
-        enum mali_wrap_mode wrap_r : 4;
-        enum mali_alt_func compare_func : 3;
-
-        /* A single set bit of unknown, ha! */
-        unsigned unknown2 : 1;
-
-        unsigned zero : 16;
-
-        uint32_t zero2;
-        float border_color[4];
-} __attribute__((packed));
-
-/* TODO: What are the floats? Apparently always { -inf, -inf, inf, inf },
- * unless the scissor test is enabled.
- *
- * viewport0/viewport1 form the arguments to glViewport. viewport1 is modified
- * by MALI_POSITIVE; viewport0 is as-is.
- */
-
-struct mali_viewport {
-        float floats[4];
-
-        float depth_range_n;
-        float depth_range_f;
-
-        u16 viewport0[2];
-        u16 viewport1[2];
-} __attribute__((packed));
-
-/* TODO: Varying meta is symmetrical with attr_meta, but there is some
- * weirdness associated. Figure it out. */
-
-struct mali_unknown6 {
-        u64 unknown0;
-        u64 unknown1;
-};
-
-/* From presentations, 16x16 tiles externally. Use shift for fast computation
- * of tile numbers. */
-
-#define MALI_TILE_SHIFT 4
-#define MALI_TILE_LENGTH (1 << MALI_TILE_SHIFT)
-
-/* Tile coordinates are stored as a compact u32, as only 12 bits are needed to
- * each component. Notice that this provides a theoretical upper bound of (1 <<
- * 12) = 4096 tiles in each direction, addressing a maximum framebuffer of size
- * 65536x65536. Multiplying that together, times another four given that Mali
- * framebuffers are 32-bit ARGB8888, means that this upper bound would take 16
- * gigabytes of RAM just to store the uncompressed framebuffer itself, let
- * alone rendering in real-time to such a buffer.
- *
- * Nice job, guys.*/
-
-/* From mali_kbase_10969_workaround.c */
-#define MALI_X_COORD_MASK 0x00000FFF
-#define MALI_Y_COORD_MASK 0x0FFF0000
-
-/* Extract parts of a tile coordinate */
-
-#define MALI_TILE_COORD_X(coord) ((coord) & MALI_X_COORD_MASK)
-#define MALI_TILE_COORD_Y(coord) (((coord) & MALI_Y_COORD_MASK) >> 16)
-#define MALI_TILE_COORD_FLAGS(coord) ((coord) & ~(MALI_X_COORD_MASK | MALI_Y_COORD_MASK))
-
-/* No known flags yet, but just in case...? */
-
-#define MALI_TILE_NO_FLAG (0)
-
-/* Helpers to generate tile coordinates based on the boundary coordinates in
- * screen space. So, with the bounds (0, 0) to (128, 128) for the screen, these
- * functions would convert it to the bounding tiles (0, 0) to (7, 7).
- * Intentional "off-by-one"; finding the tile number is a form of fencepost
- * problem. */
-
-#define MALI_MAKE_TILE_COORDS(X, Y) ((X) | ((Y) << 16))
-#define MALI_BOUND_TO_TILE(B, bias) ((B - bias) >> MALI_TILE_SHIFT)
-#define MALI_COORDINATE_TO_TILE(W, H, bias) MALI_MAKE_TILE_COORDS(MALI_BOUND_TO_TILE(W, bias), MALI_BOUND_TO_TILE(H, bias))
-#define MALI_COORDINATE_TO_TILE_MIN(W, H) MALI_COORDINATE_TO_TILE(W, H, 0)
-#define MALI_COORDINATE_TO_TILE_MAX(W, H) MALI_COORDINATE_TO_TILE(W, H, 1)
-
-struct mali_payload_fragment {
-        u32 min_tile_coord;
-        u32 max_tile_coord;
-        mali_ptr framebuffer;
-} __attribute__((packed));
-
-/* (Single?) Framebuffer Descriptor */
-
-/* Flags apply to format. With just MSAA_A and MSAA_B, the framebuffer is
- * configured for 4x. With MSAA_8, it is configured for 8x. */
-
-#define MALI_FRAMEBUFFER_MSAA_8 (1 << 3)
-#define MALI_FRAMEBUFFER_MSAA_A (1 << 4)
-#define MALI_FRAMEBUFFER_MSAA_B (1 << 23)
-
-/* Fast/slow based on whether all three buffers are cleared at once */
-
-#define MALI_CLEAR_FAST         (1 << 18)
-#define MALI_CLEAR_SLOW         (1 << 28)
-#define MALI_CLEAR_SLOW_STENCIL (1 << 31)
-
-struct mali_single_framebuffer {
-        u32 unknown1;
-        u32 unknown2;
-        u64 unknown_address_0;
-        u64 zero1;
-        u64 zero0;
-
-        /* Exact format is ironically not known, since EGL is finnicky with the
-         * blob. MSAA, colourspace, etc are configured here. */
-
-        u32 format;
-
-        u32 clear_flags;
-        u32 zero2;
-
-        /* Purposeful off-by-one in these fields should be accounted for by the
-         * MALI_DIMENSION macro */
-
-        u16 width;
-        u16 height;
-
-        u32 zero3[8];
-
-        /* By default, the framebuffer is upside down from OpenGL's
-         * perspective. Set framebuffer to the end and negate the stride to
-         * flip in the Y direction */
-
-        mali_ptr framebuffer;
-        int32_t stride;
-
-        u32 zero4;
-
-        /* Depth and stencil buffers are interleaved, it appears, as they are
-         * set to the same address in captures. Both fields set to zero if the
-         * buffer is not being cleared. Depending on GL_ENABLE magic, you might
-         * get a zero enable despite the buffer being present; that still is
-         * disabled. */
-
-        mali_ptr depth_buffer; // not SAME_VA
-        u64 depth_buffer_enable;
-
-        mali_ptr stencil_buffer; // not SAME_VA
-        u64 stencil_buffer_enable;
-
-        u32 clear_color_1; // RGBA8888 from glClear, actually used by hardware
-        u32 clear_color_2; // always equal, but unclear function?
-        u32 clear_color_3; // always equal, but unclear function?
-        u32 clear_color_4; // always equal, but unclear function?
-
-        /* Set to zero if not cleared */
-
-        float clear_depth_1; // float32, ditto
-        float clear_depth_2; // float32, ditto
-        float clear_depth_3; // float32, ditto
-        float clear_depth_4; // float32, ditto
-
-        u32 clear_stencil; // Exactly as it appears in OpenGL
-
-        u32 zero6[7];
-
-        /* Very weird format, see generation code in trans_builder.c */
-        u32 resolution_check;
-
-        u32 tiler_flags;
-
-        u64 unknown_address_1; /* Pointing towards... a zero buffer? */
-        u64 unknown_address_2;
-
-        /* See mali_kbase_replay.c */
-        u64 tiler_heap_free;
-        u64 tiler_heap_end;
-
-        /* More below this, maybe */
-} __attribute__((packed));
-
-/* Format bits for the render target */
-
-#define MALI_MFBD_FORMAT_AFBC 	  (1 << 10)
-#define MALI_MFBD_FORMAT_MSAA 	  (1 << 12)
-#define MALI_MFBD_FORMAT_NO_ALPHA (1 << 25)
-
-struct bifrost_render_target {
-        u32 unk1; // = 0x4000000
-        u32 format;
-
-        u64 zero1;
-
-        union {
-                struct {
-                        /* Stuff related to ARM Framebuffer Compression. When AFBC is enabled,
-                         * there is an extra metadata buffer that contains 16 bytes per tile.
-                         * The framebuffer needs to be the same size as before, since we don't
-                         * know ahead of time how much space it will take up. The
-                         * framebuffer_stride is set to 0, since the data isn't stored linearly
-                         * anymore.
-                         */
-
-                        mali_ptr metadata;
-                        u32 stride; // stride in units of tiles
-                        u32 unk; // = 0x20000
-                } afbc;
-
-                struct {
-                        /* Heck if I know */
-                        u64 unk;
-                        mali_ptr pointer;
-                } chunknown;
-        };
-
-        mali_ptr framebuffer;
-
-        u32 zero2 : 4;
-        u32 framebuffer_stride : 28; // in units of bytes
-        u32 zero3;
-
-        u32 clear_color_1; // RGBA8888 from glClear, actually used by hardware
-        u32 clear_color_2; // always equal, but unclear function?
-        u32 clear_color_3; // always equal, but unclear function?
-        u32 clear_color_4; // always equal, but unclear function?
-} __attribute__((packed));
-
-/* An optional part of bifrost_framebuffer. It comes between the main structure
- * and the array of render targets. It must be included if any of these are
- * enabled:
- *
- * - Transaction Elimination
- * - Depth/stencil
- * - TODO: Anything else?
- */
-
-struct bifrost_fb_extra {
-        mali_ptr checksum;
-        /* Each tile has an 8 byte checksum, so the stride is "width in tiles * 8" */
-        u32 checksum_stride;
-
-        u32 unk;
-
-        union {
-                /* Note: AFBC is only allowed for 24/8 combined depth/stencil. */
-                struct {
-                        mali_ptr depth_stencil_afbc_metadata;
-                        u32 depth_stencil_afbc_stride; // in units of tiles
-                        u32 zero1;
-
-                        mali_ptr depth_stencil;
-
-                        u64 padding;
-                } ds_afbc;
-
-                struct {
-                        /* Depth becomes depth/stencil in case of combined D/S */
-                        mali_ptr depth;
-                        u32 depth_stride_zero : 4;
-                        u32 depth_stride : 28;
-                        u32 zero1;
-
-                        mali_ptr stencil;
-                        u32 stencil_stride_zero : 4;
-                        u32 stencil_stride : 28;
-                        u32 zero2;
-                } ds_linear;
-        };
-
-
-        u64 zero3, zero4;
-} __attribute__((packed));
-
-/* flags for unk3 */
-#define MALI_MFBD_EXTRA (1 << 13)
-
-struct bifrost_framebuffer {
-        u32 unk0; // = 0x10
-        u32 zero1;
-        u64 zero2;
-        /* 0x10 */
-        mali_ptr sample_locations;
-        mali_ptr unknown1;
-        /* 0x20 */
-        u16 width1, height1;
-        u32 zero3;
-        u16 width2, height2;
-        u32 unk1 : 19; // = 0x01000
-        u32 rt_count_1 : 2; // off-by-one (use MALI_POSITIVE)
-        u32 unk2 : 3; // = 0
-        u32 rt_count_2 : 3; // no off-by-one
-        u32 zero4 : 5;
-        /* 0x30 */
-        u32 clear_stencil : 8;
-        u32 unk3 : 24; // = 0x100
-        float clear_depth;
-        mali_ptr tiler_meta;
-        /* 0x40 */
-        u64 zero5, zero6, zero7, zero8, zero9, zero10, zero11, zero12;
-
-        /* optional: struct bifrost_fb_extra extra */
-        /* struct bifrost_render_target rts[] */
-} __attribute__((packed));
-
-#endif /* __MALI_JOB_H__ */
diff --git a/src/gallium/drivers/panfrost/include/panfrost-int.h b/src/gallium/drivers/panfrost/include/panfrost-int.h
new file mode 100644
index 0000000..213b1d3
--- /dev/null
+++ b/src/gallium/drivers/panfrost/include/panfrost-int.h
@@ -0,0 +1,40 @@
+/*
+ * © Copyright 2017-2018 The Panfrost Community
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef __PANFROST_INT_H__
+#define __PANFROST_INT_H__
+
+#include <inttypes.h>
+
+typedef uint8_t  u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+typedef int8_t  s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+
+#endif
diff --git a/src/gallium/drivers/panfrost/include/panfrost-ioctl.h b/src/gallium/drivers/panfrost/include/panfrost-ioctl.h
new file mode 100644
index 0000000..fa6f77a
--- /dev/null
+++ b/src/gallium/drivers/panfrost/include/panfrost-ioctl.h
@@ -0,0 +1,926 @@
+/*
+ * © Copyright 2008-2018 ARM Limited.
+ * © Copyright 2017-2018 Lyude Paul
+ * © Copyright 2017-2018 Alyssa Rosenzweig
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU license.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+/**
+ * Definitions for all of the ioctls for the original open source Midgard/Bifrost GPU
+ * kernel driver, written by ARM.
+ */
+
+#ifndef __PANFROST_IOCTL_H__
+#define __PANFROST_IOCTL_H__
+
+#include "panfrost-int.h"
+
+#define MALI_GPU_NUM_TEXTURE_FEATURES_REGISTERS 3
+#define MALI_GPU_MAX_JOB_SLOTS 16
+#define MALI_MAX_COHERENT_GROUPS 16
+
+typedef u8 mali_atom_id;
+
+/**
+ * Since these structs are passed to and from the kernel we need to make sure
+ * that we get the size of each struct to match exactly what the kernel is
+ * expecting. So, when editing this file make sure to add static asserts that
+ * check each struct's size against the arg length you see in strace.
+ */
+
+enum mali_ioctl_mem_flags {
+        /* IN */
+        MALI_MEM_PROT_CPU_RD = (1U << 0),      /**< Read access CPU side */
+        MALI_MEM_PROT_CPU_WR = (1U << 1),      /**< Write access CPU side */
+        MALI_MEM_PROT_GPU_RD = (1U << 2),      /**< Read access GPU side */
+        MALI_MEM_PROT_GPU_WR = (1U << 3),      /**< Write access GPU side */
+        MALI_MEM_PROT_GPU_EX = (1U << 4),      /**< Execute allowed on the GPU
+						    side */
+
+        MALI_MEM_GROW_ON_GPF = (1U << 9),      /**< Grow backing store on GPU
+						    Page Fault */
+
+        MALI_MEM_COHERENT_SYSTEM = (1U << 10), /**< Page coherence Outer
+						    shareable, if available */
+        MALI_MEM_COHERENT_LOCAL = (1U << 11),  /**< Page coherence Inner
+						    shareable */
+        MALI_MEM_CACHED_CPU = (1U << 12),      /**< Should be cached on the
+						    CPU */
+
+        /* IN/OUT */
+        MALI_MEM_SAME_VA = (1U << 13), /**< Must have same VA on both the GPU
+					    and the CPU */
+        /* OUT */
+        MALI_MEM_NEED_MMAP = (1U << 14), /**< Must call mmap to acquire a GPU
+					     address for the alloc */
+        /* IN */
+        MALI_MEM_COHERENT_SYSTEM_REQUIRED = (1U << 15), /**< Page coherence
+					     Outer shareable, required. */
+        MALI_MEM_SECURE = (1U << 16),          /**< Secure memory */
+        MALI_MEM_DONT_NEED = (1U << 17),       /**< Not needed physical
+						    memory */
+        MALI_MEM_IMPORT_SHARED = (1U << 18),   /**< Must use shared CPU/GPU zone
+						    (SAME_VA zone) but doesn't
+						    require the addresses to
+						    be the same */
+};
+
+#define MALI_IOCTL_MEM_FLAGS_IN_MASK                                          \
+	(MALI_MEM_PROT_CPU_RD | MALI_MEM_PROT_CPU_WR |                        \
+	 MALI_MEM_PROT_GPU_RD | MALI_MEM_PROT_GPU_WR | MALI_MEM_PROT_GPU_EX | \
+	 MALI_MEM_GROW_ON_GPF |                                               \
+	 MALI_MEM_COHERENT_SYSTEM | MALI_MEM_COHERENT_LOCAL |                 \
+	 MALI_MEM_CACHED_CPU |                                                \
+	 MALI_MEM_COHERENT_SYSTEM_REQUIRED | MALI_MEM_SECURE |                \
+	 MALI_MEM_DONT_NEED | MALI_MEM_IMPORT_SHARED)
+#define MALI_MEM_MAP_TRACKING_HANDLE (3ull << 12)
+
+enum mali_ioctl_coherency_mode {
+        COHERENCY_ACE_LITE = 0,
+        COHERENCY_ACE      = 1,
+        COHERENCY_NONE     = 31
+};
+
+/**
+ * @brief Job dependency type.
+ *
+ * A flags field will be inserted into the atom structure to specify whether a
+ * dependency is a data or ordering dependency (by putting it before/after
+ * 'core_req' in the structure it should be possible to add without changing
+ * the structure size).  When the flag is set for a particular dependency to
+ * signal that it is an ordering only dependency then errors will not be
+ * propagated.
+ */
+typedef u8 mali_jd_dep_type;
+#define MALI_JD_DEP_TYPE_INVALID  (0)       /**< Invalid dependency */
+#define MALI_JD_DEP_TYPE_DATA     (1U << 0) /**< Data dependency */
+#define MALI_JD_DEP_TYPE_ORDER    (1U << 1) /**< Order dependency */
+
+/**
+ * @brief Job chain hardware requirements.
+ *
+ * A job chain must specify what GPU features it needs to allow the
+ * driver to schedule the job correctly.  By not specifying the
+ * correct settings can/will cause an early job termination.  Multiple
+ * values can be ORed together to specify multiple requirements.
+ * Special case is ::MALI_JD_REQ_DEP, which is used to express complex
+ * dependencies, and that doesn't execute anything on the hardware.
+ */
+typedef u32 mali_jd_core_req;
+
+/* Requirements that come from the HW */
+
+/**
+ * No requirement, dependency only
+ */
+#define MALI_JD_REQ_DEP ((mali_jd_core_req)0)
+
+/**
+ * Requires fragment shaders
+ */
+#define MALI_JD_REQ_FS  ((mali_jd_core_req)1 << 0)
+
+/**
+ * Requires compute shaders
+ * This covers any of the following Midgard Job types:
+ * - Vertex Shader Job
+ * - Geometry Shader Job
+ * - An actual Compute Shader Job
+ *
+ * Compare this with @ref MALI_JD_REQ_ONLY_COMPUTE, which specifies that the
+ * job is specifically just the "Compute Shader" job type, and not the "Vertex
+ * Shader" nor the "Geometry Shader" job type.
+ */
+#define MALI_JD_REQ_CS  ((mali_jd_core_req)1 << 1)
+#define MALI_JD_REQ_T   ((mali_jd_core_req)1 << 2)   /**< Requires tiling */
+#define MALI_JD_REQ_CF  ((mali_jd_core_req)1 << 3)   /**< Requires cache flushes */
+#define MALI_JD_REQ_V   ((mali_jd_core_req)1 << 4)   /**< Requires value writeback */
+
+/* SW-only requirements - the HW does not expose these as part of the job slot
+ * capabilities */
+
+/* Requires fragment job with AFBC encoding */
+#define MALI_JD_REQ_FS_AFBC  ((mali_jd_core_req)1 << 13)
+
+/**
+ * SW-only requirement: coalesce completion events.
+ * If this bit is set then completion of this atom will not cause an event to
+ * be sent to userspace, whether successful or not; completion events will be
+ * deferred until an atom completes which does not have this bit set.
+ *
+ * This bit may not be used in combination with MALI_JD_REQ_EXTERNAL_RESOURCES.
+ */
+#define MALI_JD_REQ_EVENT_COALESCE ((mali_jd_core_req)1 << 5)
+
+/**
+ * SW Only requirement: the job chain requires a coherent core group. We don't
+ * mind which coherent core group is used.
+ */
+#define MALI_JD_REQ_COHERENT_GROUP  ((mali_jd_core_req)1 << 6)
+
+/**
+ * SW Only requirement: The performance counters should be enabled only when
+ * they are needed, to reduce power consumption.
+ */
+
+#define MALI_JD_REQ_PERMON               ((mali_jd_core_req)1 << 7)
+
+/**
+ * SW Only requirement: External resources are referenced by this atom.  When
+ * external resources are referenced no syncsets can be bundled with the atom
+ * but should instead be part of a NULL jobs inserted into the dependency
+ * tree.  The first pre_dep object must be configured for the external
+ * resouces to use, the second pre_dep object can be used to create other
+ * dependencies.
+ *
+ * This bit may not be used in combination with MALI_JD_REQ_EVENT_COALESCE.
+ */
+#define MALI_JD_REQ_EXTERNAL_RESOURCES   ((mali_jd_core_req)1 << 8)
+
+/**
+ * SW Only requirement: Software defined job. Jobs with this bit set will not
+ * be submitted to the hardware but will cause some action to happen within
+ * the driver
+ */
+#define MALI_JD_REQ_SOFT_JOB        ((mali_jd_core_req)1 << 9)
+
+#define MALI_JD_REQ_SOFT_DUMP_CPU_GPU_TIME      (MALI_JD_REQ_SOFT_JOB | 0x1)
+#define MALI_JD_REQ_SOFT_FENCE_TRIGGER          (MALI_JD_REQ_SOFT_JOB | 0x2)
+#define MALI_JD_REQ_SOFT_FENCE_WAIT             (MALI_JD_REQ_SOFT_JOB | 0x3)
+
+/**
+ * SW Only requirement : Replay job.
+ *
+ * If the preceding job fails, the replay job will cause the jobs specified in
+ * the list of mali_jd_replay_payload pointed to by the jc pointer to be
+ * replayed.
+ *
+ * A replay job will only cause jobs to be replayed up to MALIP_JD_REPLAY_LIMIT
+ * times. If a job fails more than MALIP_JD_REPLAY_LIMIT times then the replay
+ * job is failed, as well as any following dependencies.
+ *
+ * The replayed jobs will require a number of atom IDs. If there are not enough
+ * free atom IDs then the replay job will fail.
+ *
+ * If the preceding job does not fail, then the replay job is returned as
+ * completed.
+ *
+ * The replayed jobs will never be returned to userspace. The preceding failed
+ * job will be returned to userspace as failed; the status of this job should
+ * be ignored. Completion should be determined by the status of the replay soft
+ * job.
+ *
+ * In order for the jobs to be replayed, the job headers will have to be
+ * modified. The Status field will be reset to NOT_STARTED. If the Job Type
+ * field indicates a Vertex Shader Job then it will be changed to Null Job.
+ *
+ * The replayed jobs have the following assumptions :
+ *
+ * - No external resources. Any required external resources will be held by the
+ *   replay atom.
+ * - Pre-dependencies are created based on job order.
+ * - Atom numbers are automatically assigned.
+ * - device_nr is set to 0. This is not relevant as
+ *   MALI_JD_REQ_SPECIFIC_COHERENT_GROUP should not be set.
+ * - Priority is inherited from the replay job.
+ */
+#define MALI_JD_REQ_SOFT_REPLAY                 (MALI_JD_REQ_SOFT_JOB | 0x4)
+
+/**
+ * HW Requirement: Requires Compute shaders (but not Vertex or Geometry Shaders)
+ *
+ * This indicates that the Job Chain contains Midgard Jobs of the 'Compute
+ * Shaders' type.
+ *
+ * In contrast to @ref MALI_JD_REQ_CS, this does \b not indicate that the Job
+ * Chain contains 'Geometry Shader' or 'Vertex Shader' jobs.
+ */
+#define MALI_JD_REQ_ONLY_COMPUTE    ((mali_jd_core_req)1 << 10)
+
+/**
+ * HW Requirement: Use the mali_jd_atom::device_nr field to specify a
+ * particular core group
+ *
+ * If both @ref MALI_JD_REQ_COHERENT_GROUP and this flag are set, this flag
+ * takes priority
+ *
+ * This is only guaranteed to work for @ref MALI_JD_REQ_ONLY_COMPUTE atoms.
+ *
+ * If the core availability policy is keeping the required core group turned
+ * off, then the job will fail with a @ref MALI_JD_EVENT_PM_EVENT error code.
+ */
+#define MALI_JD_REQ_SPECIFIC_COHERENT_GROUP ((mali_jd_core_req)1 << 11)
+
+/**
+ * SW Flag: If this bit is set then the successful completion of this atom
+ * will not cause an event to be sent to userspace
+ */
+#define MALI_JD_REQ_EVENT_ONLY_ON_FAILURE   ((mali_jd_core_req)1 << 12)
+
+/**
+ * SW Flag: If this bit is set then completion of this atom will not cause an
+ * event to be sent to userspace, whether successful or not.
+ */
+#define MALI_JD_REQ_EVENT_NEVER ((mali_jd_core_req)1 << 14)
+
+/**
+ * SW Flag: Skip GPU cache clean and invalidation before starting a GPU job.
+ *
+ * If this bit is set then the GPU's cache will not be cleaned and invalidated
+ * until a GPU job starts which does not have this bit set or a job completes
+ * which does not have the @ref MALI_JD_REQ_SKIP_CACHE_END bit set. Do not use if
+ * the CPU may have written to memory addressed by the job since the last job
+ * without this bit set was submitted.
+ */
+#define MALI_JD_REQ_SKIP_CACHE_START ((mali_jd_core_req)1 << 15)
+
+/**
+ * SW Flag: Skip GPU cache clean and invalidation after a GPU job completes.
+ *
+ * If this bit is set then the GPU's cache will not be cleaned and invalidated
+ * until a GPU job completes which does not have this bit set or a job starts
+ * which does not have the @ref MALI_JD_REQ_SKIP_CACHE_START bti set. Do not
+ * use if the CPU may read from or partially overwrite memory addressed by the
+ * job before the next job without this bit set completes.
+ */
+#define MALI_JD_REQ_SKIP_CACHE_END ((mali_jd_core_req)1 << 16)
+
+/**
+ * These requirement bits are currently unused in mali_jd_core_req
+ */
+#define MALIP_JD_REQ_RESERVED \
+	(~(MALI_JD_REQ_ATOM_TYPE | MALI_JD_REQ_EXTERNAL_RESOURCES | \
+	MALI_JD_REQ_EVENT_ONLY_ON_FAILURE | MALIP_JD_REQ_EVENT_NEVER | \
+	MALI_JD_REQ_EVENT_COALESCE | \
+	MALI_JD_REQ_COHERENT_GROUP | MALI_JD_REQ_SPECIFIC_COHERENT_GROUP | \
+	MALI_JD_REQ_FS_AFBC | MALI_JD_REQ_PERMON | \
+	MALI_JD_REQ_SKIP_CACHE_START | MALI_JD_REQ_SKIP_CACHE_END))
+
+/**
+ * Mask of all bits in mali_jd_core_req that control the type of the atom.
+ *
+ * This allows dependency only atoms to have flags set
+ */
+#define MALI_JD_REQ_ATOM_TYPE \
+	(MALI_JD_REQ_FS | MALI_JD_REQ_CS | MALI_JD_REQ_T | MALI_JD_REQ_CF | \
+	MALI_JD_REQ_V | MALI_JD_REQ_SOFT_JOB | MALI_JD_REQ_ONLY_COMPUTE)
+
+/**
+ * Mask of all bits in mali_jd_core_req that control the type of a soft job.
+ */
+#define MALI_JD_REQ_SOFT_JOB_TYPE (MALI_JD_REQ_SOFT_JOB | 0x1f)
+
+/*
+ * Returns non-zero value if core requirements passed define a soft job or
+ * a dependency only job.
+ */
+#define MALI_JD_REQ_SOFT_JOB_OR_DEP(core_req) \
+	((core_req & MALI_JD_REQ_SOFT_JOB) || \
+	(core_req & MALI_JD_REQ_ATOM_TYPE) == MALI_JD_REQ_DEP)
+
+/**
+ * @brief The payload for a replay job. This must be in GPU memory.
+ */
+struct mali_jd_replay_payload {
+        /**
+         * Pointer to the first entry in the mali_jd_replay_jc list.  These
+         * will be replayed in @b reverse order (so that extra ones can be added
+         * to the head in future soft jobs without affecting this soft job)
+         */
+        u64 tiler_jc_list;
+
+        /**
+         * Pointer to the fragment job chain.
+         */
+        u64 fragment_jc;
+
+        /**
+         * Pointer to the tiler heap free FBD field to be modified.
+         */
+        u64 tiler_heap_free;
+
+        /**
+         * Hierarchy mask for the replayed fragment jobs. May be zero.
+         */
+        u16 fragment_hierarchy_mask;
+
+        /**
+         * Hierarchy mask for the replayed tiler jobs. May be zero.
+         */
+        u16 tiler_hierarchy_mask;
+
+        /**
+         * Default weight to be used for hierarchy levels not in the original
+         * mask.
+         */
+        u32 hierarchy_default_weight;
+
+        /**
+         * Core requirements for the tiler job chain
+         */
+        mali_jd_core_req tiler_core_req;
+
+        /**
+         * Core requirements for the fragment job chain
+         */
+        mali_jd_core_req fragment_core_req;
+};
+
+/**
+ * @brief An entry in the linked list of job chains to be replayed. This must
+ *        be in GPU memory.
+ */
+struct mali_jd_replay_jc {
+        /**
+         * Pointer to next entry in the list. A setting of NULL indicates the
+         * end of the list.
+         */
+        u64 next;
+
+        /**
+         * Pointer to the job chain.
+         */
+        u64 jc;
+};
+
+/* Capabilities of a job slot as reported by JS_FEATURES registers */
+
+#define JS_FEATURE_NULL_JOB              (1u << 1)
+#define JS_FEATURE_SET_VALUE_JOB         (1u << 2)
+#define JS_FEATURE_CACHE_FLUSH_JOB       (1u << 3)
+#define JS_FEATURE_COMPUTE_JOB           (1u << 4)
+#define JS_FEATURE_VERTEX_JOB            (1u << 5)
+#define JS_FEATURE_GEOMETRY_JOB          (1u << 6)
+#define JS_FEATURE_TILER_JOB             (1u << 7)
+#define JS_FEATURE_FUSED_JOB             (1u << 8)
+#define JS_FEATURE_FRAGMENT_JOB          (1u << 9)
+
+struct mali_gpu_core_props {
+        /**
+         * Product specific value.
+         */
+        u32 product_id;
+
+        /**
+         * Status of the GPU release.
+         * No defined values, but starts at 0 and increases by one for each
+         * release status (alpha, beta, EAC, etc.).
+         * 4 bit values (0-15).
+         */
+        u16 version_status;
+
+        /**
+         * Minor release number of the GPU. "P" part of an "RnPn" release
+         * number.
+         * 8 bit values (0-255).
+         */
+        u16 minor_revision;
+
+        /**
+         * Major release number of the GPU. "R" part of an "RnPn" release
+         * number.
+         * 4 bit values (0-15).
+         */
+        u16 major_revision;
+
+        u16 : 16;
+
+        /**
+         * @usecase GPU clock speed is not specified in the Midgard
+         * Architecture, but is <b>necessary for OpenCL's clGetDeviceInfo()
+         * function</b>.
+         */
+        u32 gpu_speed_mhz;
+
+        /**
+         * @usecase GPU clock max/min speed is required for computing
+         * best/worst case in tasks as job scheduling ant irq_throttling. (It
+         * is not specified in the Midgard Architecture).
+         */
+        u32 gpu_freq_khz_max;
+        u32 gpu_freq_khz_min;
+
+        /**
+         * Size of the shader program counter, in bits.
+         */
+        u32 log2_program_counter_size;
+
+        /**
+         * TEXTURE_FEATURES_x registers, as exposed by the GPU. This is a
+         * bitpattern where a set bit indicates that the format is supported.
+         *
+         * Before using a texture format, it is recommended that the
+         * corresponding bit be checked.
+         */
+        u32 texture_features[MALI_GPU_NUM_TEXTURE_FEATURES_REGISTERS];
+
+        /**
+         * Theoretical maximum memory available to the GPU. It is unlikely
+         * that a client will be able to allocate all of this memory for their
+         * own purposes, but this at least provides an upper bound on the
+         * memory available to the GPU.
+         *
+         * This is required for OpenCL's clGetDeviceInfo() call when
+         * CL_DEVICE_GLOBAL_MEM_SIZE is requested, for OpenCL GPU devices. The
+         * client will not be expecting to allocate anywhere near this value.
+         */
+        u64 gpu_available_memory_size;
+};
+
+struct mali_gpu_l2_cache_props {
+        u8 log2_line_size;
+        u8 log2_cache_size;
+        u8 num_l2_slices; /* Number of L2C slices. 1 or higher */
+        u64 : 40;
+};
+
+struct mali_gpu_tiler_props {
+        u32 bin_size_bytes;	/* Max is 4*2^15 */
+        u32 max_active_levels;	/* Max is 2^15 */
+};
+
+struct mali_gpu_thread_props {
+        u32 max_threads;            /* Max. number of threads per core */
+        u32 max_workgroup_size;     /* Max. number of threads per workgroup */
+        u32 max_barrier_size;       /* Max. number of threads that can
+				       synchronize on a simple barrier */
+        u16 max_registers;          /* Total size [1..65535] of the register
+				       file available per core. */
+        u8  max_task_queue;         /* Max. tasks [1..255] which may be sent
+				       to a core before it becomes blocked. */
+        u8  max_thread_group_split; /* Max. allowed value [1..15] of the
+				       Thread Group Split field. */
+        enum {
+                MALI_GPU_IMPLEMENTATION_UNKNOWN = 0,
+                MALI_GPU_IMPLEMENTATION_SILICON = 1,
+                MALI_GPU_IMPLEMENTATION_FPGA    = 2,
+                MALI_GPU_IMPLEMENTATION_SW      = 3,
+        } impl_tech : 8;
+        u64 : 56;
+};
+
+/**
+ * @brief descriptor for a coherent group
+ *
+ * \c core_mask exposes all cores in that coherent group, and \c num_cores
+ * provides a cached population-count for that mask.
+ *
+ * @note Whilst all cores are exposed in the mask, not all may be available to
+ * the application, depending on the Kernel Power policy.
+ *
+ * @note if u64s must be 8-byte aligned, then this structure has 32-bits of
+ * wastage.
+ */
+struct mali_ioctl_gpu_coherent_group {
+        u64 core_mask;	       /**< Core restriction mask required for the
+				 group */
+        u16 num_cores;	       /**< Number of cores in the group */
+        u64 : 48;
+};
+
+/**
+ * @brief Coherency group information
+ *
+ * Note that the sizes of the members could be reduced. However, the \c group
+ * member might be 8-byte aligned to ensure the u64 core_mask is 8-byte
+ * aligned, thus leading to wastage if the other members sizes were reduced.
+ *
+ * The groups are sorted by core mask. The core masks are non-repeating and do
+ * not intersect.
+ */
+struct mali_gpu_coherent_group_info {
+        u32 num_groups;
+
+        /**
+         * Number of core groups (coherent or not) in the GPU. Equivalent to
+         * the number of L2 Caches.
+         *
+         * The GPU Counter dumping writes 2048 bytes per core group,
+         * regardless of whether the core groups are coherent or not. Hence
+         * this member is needed to calculate how much memory is required for
+         * dumping.
+         *
+         * @note Do not use it to work out how many valid elements are in the
+         * group[] member. Use num_groups instead.
+         */
+        u32 num_core_groups;
+
+        /**
+         * Coherency features of the memory, accessed by @ref gpu_mem_features
+         * methods
+         */
+        u32 coherency;
+
+        u32 : 32;
+
+        /**
+         * Descriptors of coherent groups
+         */
+        struct mali_ioctl_gpu_coherent_group group[MALI_MAX_COHERENT_GROUPS];
+};
+
+/**
+ * A complete description of the GPU's Hardware Configuration Discovery
+ * registers.
+ *
+ * The information is presented inefficiently for access. For frequent access,
+ * the values should be better expressed in an unpacked form in the
+ * base_gpu_props structure.
+ *
+ * @usecase The raw properties in @ref gpu_raw_gpu_props are necessary to
+ * allow a user of the Mali Tools (e.g. PAT) to determine "Why is this device
+ * behaving differently?". In this case, all information about the
+ * configuration is potentially useful, but it <b>does not need to be processed
+ * by the driver</b>. Instead, the raw registers can be processed by the Mali
+ * Tools software on the host PC.
+ *
+ */
+struct mali_gpu_raw_props {
+        u64 shader_present;
+        u64 tiler_present;
+        u64 l2_present;
+        u64 stack_present;
+
+        u32 l2_features;
+        u32 suspend_size; /* API 8.2+ */
+        u32 mem_features;
+        u32 mmu_features;
+
+        u32 as_present;
+
+        u32 js_present;
+        u32 js_features[MALI_GPU_MAX_JOB_SLOTS];
+        u32 tiler_features;
+        u32 texture_features[3];
+
+        u32 gpu_id;
+
+        u32 thread_max_threads;
+        u32 thread_max_workgroup_size;
+        u32 thread_max_barrier_size;
+        u32 thread_features;
+
+        /*
+         * Note: This is the _selected_ coherency mode rather than the
+         * available modes as exposed in the coherency_features register.
+         */
+        u32 coherency_mode;
+};
+
+
+typedef u64 mali_ptr;
+
+#define MALI_PTR_FMT "0x%" PRIx64
+#define MALI_SHORT_PTR_FMT "0x%" PRIxPTR
+
+#ifdef __LP64__
+#define PAD_CPU_PTR(p) p
+#else
+#define PAD_CPU_PTR(p) p; u32 :32;
+#endif
+
+/* FIXME: Again, they don't specify any of these as packed structs. However,
+ * looking at these structs I'm worried that there is already spots where the
+ * compiler is potentially sticking in padding...
+ * Going to try something a little crazy, and just hope that our compiler
+ * happens to add the same kind of offsets since we can't really compare sizes
+ */
+
+/*
+ * Blob provided by the driver to store callback driver, not actually modified
+ * by the driver itself
+ */
+struct mali_jd_udata {
+        u64 blob[2];
+};
+
+struct mali_jd_dependency {
+        mali_atom_id  atom_id;               /**< An atom number */
+        mali_jd_dep_type dependency_type;    /**< Dependency type */
+};
+
+#define MALI_EXT_RES_MAX 10
+
+/* The original header never explicitly defines any values for these. In C,
+ * this -should- expand to SHARED == 0 and EXCLUSIVE == 1, so the only flag we
+ * actually need to decode here is EXCLUSIVE
+ */
+enum mali_external_resource_access {
+        MALI_EXT_RES_ACCESS_SHARED,
+        MALI_EXT_RES_ACCESS_EXCLUSIVE,
+};
+
+/* An aligned address to the resource | mali_external_resource_access */
+typedef u64 mali_external_resource;
+
+struct mali_jd_atom_v2 {
+        mali_ptr jc;           /**< job-chain GPU address */
+        struct mali_jd_udata udata;	    /**< user data */
+        PAD_CPU_PTR(mali_external_resource *ext_res_list); /**< list of external resources */
+        u16 nr_ext_res;			    /**< nr of external resources */
+        u16 compat_core_req;	            /**< core requirements which
+					      correspond to the legacy support
+					      for UK 10.2 */
+        struct mali_jd_dependency pre_dep[2];  /**< pre-dependencies, one need to
+					      use SETTER function to assign
+					      this field, this is done in
+					      order to reduce possibility of
+					      improper assigment of a
+					      dependency field */
+        mali_atom_id atom_number;	    /**< unique number to identify the
+					      atom */
+        u8 prio;                  /**< Atom priority. Refer to @ref
+					      mali_jd_prio for more details */
+        u8 device_nr;			    /**< coregroup when
+					      BASE_JD_REQ_SPECIFIC_COHERENT_GROUP
+					      specified */
+        u8 : 8;
+        mali_jd_core_req core_req;          /**< core requirements */
+} __attribute__((packed));
+
+/**
+ * enum mali_error - Mali error codes shared with userspace
+ *
+ * This is subset of those common Mali errors that can be returned to userspace.
+ * Values of matching user and kernel space enumerators MUST be the same.
+ * MALI_ERROR_NONE is guaranteed to be 0.
+ *
+ * @MALI_ERROR_NONE: Success
+ * @MALI_ERROR_OUT_OF_GPU_MEMORY: Not used in the kernel driver
+ * @MALI_ERROR_OUT_OF_MEMORY: Memory allocation failure
+ * @MALI_ERROR_FUNCTION_FAILED: Generic error code
+ */
+enum mali_error {
+        MALI_ERROR_NONE = 0,
+        MALI_ERROR_OUT_OF_GPU_MEMORY,
+        MALI_ERROR_OUT_OF_MEMORY,
+        MALI_ERROR_FUNCTION_FAILED,
+};
+
+/**
+ * Header used by all ioctls
+ */
+union mali_ioctl_header {
+        /* [in] The ID of the UK function being called */
+        u32 id : 32;
+        /* [out] The return value of the UK function that was called */
+        enum mali_error rc : 32;
+
+        u64 : 64;
+} __attribute__((packed));
+
+struct mali_ioctl_get_version {
+        union mali_ioctl_header header;
+        u16 major; /* [out] */
+        u16 minor; /* [out] */
+        u32 : 32;
+} __attribute__((packed));
+
+struct mali_ioctl_mem_alloc {
+        union mali_ioctl_header header;
+        /* [in] */
+        u64 va_pages;
+        u64 commit_pages;
+        u64 extent;
+        /* [in/out] */
+        u64 flags;
+        /* [out] */
+        mali_ptr gpu_va;
+        u16 va_alignment;
+
+        u32 : 32;
+        u16 : 16;
+} __attribute__((packed));
+
+struct mali_mem_import_user_buffer {
+        u64 ptr;
+        u64 length;
+};
+
+struct mali_ioctl_mem_import {
+        union mali_ioctl_header header;
+        /* [in] */
+        u64 phandle;
+        enum {
+                MALI_MEM_IMPORT_TYPE_INVALID = 0,
+                MALI_MEM_IMPORT_TYPE_UMP = 1,
+                MALI_MEM_IMPORT_TYPE_UMM = 2,
+                MALI_MEM_IMPORT_TYPE_USER_BUFFER = 3,
+        } type : 32;
+        u32 : 32;
+        /* [in/out] */
+        u64 flags;
+        /* [out] */
+        u64 gpu_va;
+        u64 va_pages;
+} __attribute__((packed));
+
+struct mali_ioctl_mem_commit {
+        union mali_ioctl_header header;
+        /* [in] */
+        mali_ptr gpu_addr;
+        u64 pages;
+        /* [out] */
+        u32 result_subcode;
+        u32 : 32;
+} __attribute__((packed));
+
+enum mali_ioctl_mem_query_type {
+        MALI_MEM_QUERY_COMMIT_SIZE = 1,
+        MALI_MEM_QUERY_VA_SIZE     = 2,
+        MALI_MEM_QUERY_FLAGS       = 3
+};
+
+struct mali_ioctl_mem_query {
+        union mali_ioctl_header header;
+        /* [in] */
+        mali_ptr gpu_addr;
+        enum mali_ioctl_mem_query_type query : 32;
+        u32 : 32;
+        /* [out] */
+        u64 value;
+} __attribute__((packed));
+
+struct mali_ioctl_mem_free {
+        union mali_ioctl_header header;
+        mali_ptr gpu_addr; /* [in] */
+} __attribute__((packed));
+/* FIXME: Size unconfirmed (haven't seen in a trace yet) */
+
+struct mali_ioctl_mem_flags_change {
+        union mali_ioctl_header header;
+        /* [in] */
+        mali_ptr gpu_va;
+        u64 flags;
+        u64 mask;
+} __attribute__((packed));
+/* FIXME: Size unconfirmed (haven't seen in a trace yet) */
+
+struct mali_ioctl_mem_alias {
+        union mali_ioctl_header header;
+        /* [in/out] */
+        u64 flags;
+        /* [in] */
+        u64 stride;
+        u64 nents;
+        u64 ai;
+        /* [out] */
+        mali_ptr gpu_va;
+        u64 va_pages;
+} __attribute__((packed));
+
+struct mali_ioctl_sync {
+        union mali_ioctl_header header;
+        mali_ptr handle;
+        PAD_CPU_PTR(void *user_addr);
+        u64 size;
+        enum {
+                MALI_SYNC_TO_DEVICE = 1,
+                MALI_SYNC_TO_CPU = 2,
+        } type : 8;
+        u64 : 56;
+} __attribute__((packed));
+
+struct mali_ioctl_gpu_props_reg_dump {
+        union mali_ioctl_header header;
+        struct mali_gpu_core_props core;
+        struct mali_gpu_l2_cache_props l2;
+        u64 : 64;
+        struct mali_gpu_tiler_props tiler;
+        struct mali_gpu_thread_props thread;
+
+        struct mali_gpu_raw_props raw;
+
+        /** This must be last member of the structure */
+        struct mali_gpu_coherent_group_info coherency_info;
+} __attribute__((packed));
+
+struct mali_ioctl_set_flags {
+        union mali_ioctl_header header;
+        u32 create_flags; /* [in] */
+        u32 : 32;
+} __attribute__((packed));
+
+struct mali_ioctl_stream_create {
+        union mali_ioctl_header header;
+        /* [in] */
+        char name[32];
+        /* [out] */
+        s32 fd;
+        u32 : 32;
+} __attribute__((packed));
+
+struct mali_ioctl_job_submit {
+        union mali_ioctl_header header;
+        /* [in] */
+        PAD_CPU_PTR(struct mali_jd_atom_v2 *addr);
+        u32 nr_atoms;
+        u32 stride;
+} __attribute__((packed));
+
+struct mali_ioctl_get_context_id {
+        union mali_ioctl_header header;
+        /* [out] */
+        s64 id;
+} __attribute__((packed));
+
+#undef PAD_PTR
+
+/* For ioctl's we haven't written decoding stuff for yet */
+typedef struct {
+        union mali_ioctl_header header;
+} __ioctl_placeholder;
+
+#define MALI_IOCTL_TYPE_BASE  0x80
+#define MALI_IOCTL_TYPE_MAX   0x82
+#define MALI_IOCTL_TYPE_COUNT (MALI_IOCTL_TYPE_MAX - MALI_IOCTL_TYPE_BASE + 1)
+
+#define MALI_IOCTL_GET_VERSION             (_IOWR(0x80,  0, struct mali_ioctl_get_version))
+#define MALI_IOCTL_MEM_ALLOC               (_IOWR(0x82,  0, struct mali_ioctl_mem_alloc))
+#define MALI_IOCTL_MEM_IMPORT              (_IOWR(0x82,  1, struct mali_ioctl_mem_import))
+#define MALI_IOCTL_MEM_COMMIT              (_IOWR(0x82,  2, struct mali_ioctl_mem_commit))
+#define MALI_IOCTL_MEM_QUERY               (_IOWR(0x82,  3, struct mali_ioctl_mem_query))
+#define MALI_IOCTL_MEM_FREE                (_IOWR(0x82,  4, struct mali_ioctl_mem_free))
+#define MALI_IOCTL_MEM_FLAGS_CHANGE        (_IOWR(0x82,  5, struct mali_ioctl_mem_flags_change))
+#define MALI_IOCTL_MEM_ALIAS               (_IOWR(0x82,  6, struct mali_ioctl_mem_alias))
+#define MALI_IOCTL_SYNC                    (_IOWR(0x82,  8, struct mali_ioctl_sync))
+#define MALI_IOCTL_POST_TERM               (_IOWR(0x82,  9, __ioctl_placeholder))
+#define MALI_IOCTL_HWCNT_SETUP             (_IOWR(0x82, 10, __ioctl_placeholder))
+#define MALI_IOCTL_HWCNT_DUMP              (_IOWR(0x82, 11, __ioctl_placeholder))
+#define MALI_IOCTL_HWCNT_CLEAR             (_IOWR(0x82, 12, __ioctl_placeholder))
+#define MALI_IOCTL_GPU_PROPS_REG_DUMP      (_IOWR(0x82, 14, struct mali_ioctl_gpu_props_reg_dump))
+#define MALI_IOCTL_FIND_CPU_OFFSET         (_IOWR(0x82, 15, __ioctl_placeholder))
+#define MALI_IOCTL_GET_VERSION_NEW         (_IOWR(0x82, 16, struct mali_ioctl_get_version))
+#define MALI_IOCTL_SET_FLAGS               (_IOWR(0x82, 18, struct mali_ioctl_set_flags))
+#define MALI_IOCTL_SET_TEST_DATA           (_IOWR(0x82, 19, __ioctl_placeholder))
+#define MALI_IOCTL_INJECT_ERROR            (_IOWR(0x82, 20, __ioctl_placeholder))
+#define MALI_IOCTL_MODEL_CONTROL           (_IOWR(0x82, 21, __ioctl_placeholder))
+#define MALI_IOCTL_KEEP_GPU_POWERED        (_IOWR(0x82, 22, __ioctl_placeholder))
+#define MALI_IOCTL_FENCE_VALIDATE          (_IOWR(0x82, 23, __ioctl_placeholder))
+#define MALI_IOCTL_STREAM_CREATE           (_IOWR(0x82, 24, struct mali_ioctl_stream_create))
+#define MALI_IOCTL_GET_PROFILING_CONTROLS  (_IOWR(0x82, 25, __ioctl_placeholder))
+#define MALI_IOCTL_SET_PROFILING_CONTROLS  (_IOWR(0x82, 26, __ioctl_placeholder))
+#define MALI_IOCTL_DEBUGFS_MEM_PROFILE_ADD (_IOWR(0x82, 27, __ioctl_placeholder))
+#define MALI_IOCTL_JOB_SUBMIT              (_IOWR(0x82, 28, struct mali_ioctl_job_submit))
+#define MALI_IOCTL_DISJOINT_QUERY          (_IOWR(0x82, 29, __ioctl_placeholder))
+#define MALI_IOCTL_GET_CONTEXT_ID          (_IOWR(0x82, 31, struct mali_ioctl_get_context_id))
+#define MALI_IOCTL_TLSTREAM_ACQUIRE_V10_4  (_IOWR(0x82, 32, __ioctl_placeholder))
+#define MALI_IOCTL_TLSTREAM_TEST           (_IOWR(0x82, 33, __ioctl_placeholder))
+#define MALI_IOCTL_TLSTREAM_STATS          (_IOWR(0x82, 34, __ioctl_placeholder))
+#define MALI_IOCTL_TLSTREAM_FLUSH          (_IOWR(0x82, 35, __ioctl_placeholder))
+#define MALI_IOCTL_HWCNT_READER_SETUP      (_IOWR(0x82, 36, __ioctl_placeholder))
+#define MALI_IOCTL_SET_PRFCNT_VALUES       (_IOWR(0x82, 37, __ioctl_placeholder))
+#define MALI_IOCTL_SOFT_EVENT_UPDATE       (_IOWR(0x82, 38, __ioctl_placeholder))
+#define MALI_IOCTL_MEM_JIT_INIT            (_IOWR(0x82, 39, __ioctl_placeholder))
+#define MALI_IOCTL_TLSTREAM_ACQUIRE        (_IOWR(0x82, 40, __ioctl_placeholder))
+
+#endif /* __PANFROST_IOCTL_H__ */
diff --git a/src/gallium/drivers/panfrost/include/panfrost-job.h b/src/gallium/drivers/panfrost/include/panfrost-job.h
new file mode 100644
index 0000000..a63a732
--- /dev/null
+++ b/src/gallium/drivers/panfrost/include/panfrost-job.h
@@ -0,0 +1,1173 @@
+/*
+ * © Copyright 2017-2018 Alyssa Rosenzweig
+ * © Copyright 2017-2018 Connor Abbott
+ * © Copyright 2017-2018 Lyude Paul
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef __PANFROST_JOB_H__
+#define __PANFROST_JOB_H__
+
+#include <panfrost-ioctl.h>
+
+#define T8XX
+
+#define MALI_SHORT_PTR_BITS (sizeof(uintptr_t)*8)
+
+#define MALI_FBD_HIERARCHY_WEIGHTS 8
+
+#define MALI_PAYLOAD_SIZE 256
+
+enum mali_job_type {
+        JOB_NOT_STARTED	= 0,
+        JOB_TYPE_NULL = 1,
+        JOB_TYPE_SET_VALUE = 2,
+        JOB_TYPE_CACHE_FLUSH = 3,
+        JOB_TYPE_COMPUTE = 4,
+        JOB_TYPE_VERTEX = 5,
+        JOB_TYPE_TILER = 7,
+        JOB_TYPE_FUSED = 8,
+        JOB_TYPE_FRAGMENT = 9,
+};
+
+enum mali_gl_mode {
+        MALI_GL_NONE           = 0x0,
+        MALI_GL_POINTS         = 0x1,
+        MALI_GL_LINES          = 0x2,
+        MALI_GL_LINE_STRIP     = 0x4,
+        MALI_GL_LINE_LOOP      = 0x6,
+        MALI_GL_TRIANGLES      = 0x8,
+        MALI_GL_TRIANGLE_STRIP = 0xA,
+        MALI_GL_TRIANGLE_FAN   = 0xC,
+};
+
+#define MALI_GL_CULL_FACE_BACK  0x80
+#define MALI_GL_CULL_FACE_FRONT 0x40
+
+#define MALI_GL_FRONT_FACE(v) (v << 5)
+#define MALI_GL_CCW (0)
+#define MALI_GL_CW  (1)
+
+/* TODO: Might this actually be a finer bitfield? */
+#define MALI_DEPTH_STENCIL_ENABLE 0x6400
+
+#define DS_ENABLE(field) \
+	(field == MALI_DEPTH_STENCIL_ENABLE) \
+	? "MALI_DEPTH_STENCIL_ENABLE" \
+	: (field == 0) ? "0" \
+	: "0 /* XXX: Unknown, check hexdump */"
+
+/* Used in stencil and depth tests */
+
+enum mali_func {
+        MALI_FUNC_NEVER    = 0,
+        MALI_FUNC_LESS     = 1,
+        MALI_FUNC_EQUAL    = 2,
+        MALI_FUNC_LEQUAL   = 3,
+        MALI_FUNC_GREATER  = 4,
+        MALI_FUNC_NOTEQUAL = 5,
+        MALI_FUNC_GEQUAL   = 6,
+        MALI_FUNC_ALWAYS   = 7
+};
+
+/* Same OpenGL, but mixed up. Why? Because forget me, that's why! */
+
+enum mali_alt_func {
+        MALI_ALT_FUNC_NEVER    = 0,
+        MALI_ALT_FUNC_GREATER  = 1,
+        MALI_ALT_FUNC_EQUAL    = 2,
+        MALI_ALT_FUNC_GEQUAL   = 3,
+        MALI_ALT_FUNC_LESS     = 4,
+        MALI_ALT_FUNC_NOTEQUAL = 5,
+        MALI_ALT_FUNC_LEQUAL   = 6,
+        MALI_ALT_FUNC_ALWAYS   = 7
+};
+
+/* Flags apply to unknown2_3? */
+
+#define MALI_HAS_MSAA		(1 << 0)
+#define MALI_CAN_DISCARD 	(1 << 5)
+
+/* Applies on T6XX, specifying that programmable blending is in use */
+#define MALI_HAS_BLEND_SHADER 	(1 << 6)
+
+/* func is mali_func */
+#define MALI_DEPTH_FUNC(func)	   (func << 8)
+#define MALI_GET_DEPTH_FUNC(flags) ((flags >> 8) & 0x7)
+#define MALI_DEPTH_FUNC_MASK	   MALI_DEPTH_FUNC(0x7)
+
+#define MALI_DEPTH_TEST		(1 << 11)
+
+/* Next flags to unknown2_4 */
+#define MALI_STENCIL_TEST      	(1 << 0)
+
+/* What?! */
+#define MALI_SAMPLE_ALPHA_TO_COVERAGE_NO_BLEND_SHADER (1 << 1)
+
+#define MALI_NO_DITHER		(1 << 9)
+#define MALI_DEPTH_RANGE_A	(1 << 12)
+#define MALI_DEPTH_RANGE_B	(1 << 13)
+#define MALI_NO_MSAA		(1 << 14)
+
+/* Stencil test state is all encoded in a single u32, just with a lot of
+ * enums... */
+
+enum mali_stencil_op {
+        MALI_STENCIL_KEEP 	= 0,
+        MALI_STENCIL_REPLACE 	= 1,
+        MALI_STENCIL_ZERO 	= 2,
+        MALI_STENCIL_INVERT 	= 3,
+        MALI_STENCIL_INCR_WRAP 	= 4,
+        MALI_STENCIL_DECR_WRAP 	= 5,
+        MALI_STENCIL_INCR 	= 6,
+        MALI_STENCIL_DECR 	= 7
+};
+
+struct mali_stencil_test {
+        unsigned ref  			: 8;
+        unsigned mask 			: 8;
+        enum mali_func func 		: 3;
+        enum mali_stencil_op sfail 	: 3;
+        enum mali_stencil_op dpfail 	: 3;
+        enum mali_stencil_op dppass 	: 3;
+        unsigned zero			: 4;
+} __attribute__((packed));
+
+/* Blending is a mess, since anything fancy triggers a blend shader, and
+ * -those- are not understood whatsover yet */
+
+#define MALI_MASK_R (1 << 0)
+#define MALI_MASK_G (1 << 1)
+#define MALI_MASK_B (1 << 2)
+#define MALI_MASK_A (1 << 3)
+
+enum mali_nondominant_mode {
+        MALI_BLEND_NON_MIRROR = 0,
+        MALI_BLEND_NON_ZERO = 1
+};
+
+enum mali_dominant_blend {
+        MALI_BLEND_DOM_SOURCE = 0,
+        MALI_BLEND_DOM_DESTINATION  = 1
+};
+
+enum mali_dominant_factor {
+        MALI_DOMINANT_UNK0 = 0,
+        MALI_DOMINANT_ZERO = 1,
+        MALI_DOMINANT_SRC_COLOR = 2,
+        MALI_DOMINANT_DST_COLOR = 3,
+        MALI_DOMINANT_UNK4 = 4,
+        MALI_DOMINANT_SRC_ALPHA = 5,
+        MALI_DOMINANT_DST_ALPHA = 6,
+        MALI_DOMINANT_CONSTANT = 7,
+};
+
+enum mali_blend_modifier {
+        MALI_BLEND_MOD_UNK0 = 0,
+        MALI_BLEND_MOD_NORMAL = 1,
+        MALI_BLEND_MOD_SOURCE_ONE = 2,
+        MALI_BLEND_MOD_DEST_ONE = 3,
+};
+
+struct mali_blend_mode {
+        enum mali_blend_modifier clip_modifier : 2;
+        unsigned unused_0 : 1;
+        unsigned negate_source : 1;
+
+        enum mali_dominant_blend dominant : 1;
+
+        enum mali_nondominant_mode nondominant_mode : 1;
+
+        unsigned unused_1 : 1;
+
+        unsigned negate_dest : 1;
+
+        enum mali_dominant_factor dominant_factor : 3;
+        unsigned complement_dominant : 1;
+} __attribute__((packed));
+
+struct mali_blend_equation {
+        /* Of type mali_blend_mode */
+        unsigned rgb_mode : 12;
+        unsigned alpha_mode : 12;
+
+        unsigned zero1 : 4;
+
+        /* Corresponds to MALI_MASK_* above and glColorMask arguments */
+
+        unsigned color_mask : 4;
+
+        /* Attached constant for CONSTANT_ALPHA, etc */
+
+#ifndef BIFROST
+        float constant;
+#endif
+} __attribute__((packed));
+
+/* Alpha coverage is encoded as 4-bits (from a clampf), with inversion
+ * literally performing a bitwise invert. This function produces slightly wrong
+ * results and I'm not sure why; some rounding issue I suppose... */
+
+#define MALI_ALPHA_COVERAGE(clampf) ((uint16_t) (int) (clampf * 15.0f))
+#define MALI_GET_ALPHA_COVERAGE(nibble) ((float) nibble / 15.0f)
+
+/* Applies to unknown1 */
+#define MALI_NO_ALPHA_TO_COVERAGE (1 << 10)
+
+struct mali_blend_meta {
+#ifdef T8XX
+        /* Base value of 0x200.
+         * OR with 0x1 for blending (anything other than REPLACE).
+         * OR with 0x2 for programmable blending
+         */
+
+        u64 unk1;
+
+        /* For programmable blending, these turn into the blend_shader address */
+        struct mali_blend_equation blend_equation_1;
+
+        u64 zero2;
+        struct mali_blend_equation blend_equation_2;
+#else
+        u32 unk1; // = 0x200
+        struct mali_blend_equation blend_equation;
+        /*
+         * - 0x19 normally
+         * - 0x3 when this slot is unused (everything else is 0 except the index)
+         * - 0x11 when this is the fourth slot (and it's used)
+         */
+        u16 unk2;
+        /* increments from 0 to 3 */
+        u16 index;
+        u32 unk3; // = 0x10ed688
+#endif
+} __attribute__((packed));
+
+struct mali_shader_meta {
+        mali_ptr shader;
+        u16 texture_count;
+        u16 sampler_count;
+        u16 attribute_count;
+        u16 varying_count;
+
+        union {
+                struct {
+                        u32 uniform_buffer_count : 4;
+                        u32 unk1 : 28; // = 0x800000 for vertex, 0x958020 for tiler
+                } bifrost1;
+                struct {
+                        /* 0x200 except MALI_NO_ALPHA_TO_COVERAGE. Mysterious 1
+                         * other times. Who knows really? */
+                        u16 unknown1;
+
+                        /* Whole number of uniform registers used, times two;
+                         * whole number of work registers used (no scale).
+                         */
+                        unsigned work_count : 5;
+                        unsigned uniform_count : 5;
+                        unsigned unknown2 : 6;
+                } midgard1;
+        };
+
+        /* On bifrost: Exactly the same as glPolygonOffset() for both.
+         * On midgard: Depth factor is exactly as passed to glPolygonOffset.
+         * Depth units is equal to the value passed to glDeptOhffset + 1.0f
+         * (use MALI_NEGATIVE)
+         */
+        float depth_units;
+        float depth_factor;
+
+        u32 unknown2_2;
+
+        u16 alpha_coverage;
+        u16 unknown2_3;
+
+        u8 stencil_mask_front;
+        u8 stencil_mask_back;
+        u16 unknown2_4;
+
+        struct mali_stencil_test stencil_front;
+        struct mali_stencil_test stencil_back;
+
+        union {
+                struct {
+                        u32 unk3 : 7;
+                        /* On Bifrost, some system values are preloaded in
+                         * registers R55-R62 by the thread dispatcher prior to
+                         * the start of shader execution. This is a bitfield
+                         * with one entry for each register saying which
+                         * registers need to be preloaded. Right now, the known
+                         * values are:
+                         *
+                         * Vertex/compute:
+                         * - R55 : gl_LocalInvocationID.xy
+                         * - R56 : gl_LocalInvocationID.z + unknown in high 16 bits
+                         * - R57 : gl_WorkGroupID.x
+                         * - R58 : gl_WorkGroupID.y
+                         * - R59 : gl_WorkGroupID.z
+                         * - R60 : gl_GlobalInvocationID.x
+                         * - R61 : gl_GlobalInvocationID.y/gl_VertexID (without base)
+                         * - R62 : gl_GlobalInvocationID.z/gl_InstanceID (without base)
+                         *
+                         * Fragment:
+                         * - R55 : unknown, never seen (but the bit for this is
+                         *   always set?)
+                         * - R56 : unknown (bit always unset)
+                         * - R57 : gl_PrimitiveID
+                         * - R58 : gl_FrontFacing in low bit, potentially other stuff
+                         * - R59 : u16 fragment coordinates (used to compute
+                         *   gl_FragCoord.xy, together with sample positions)
+                         * - R60 : gl_SampleMask (used in epilog, so pretty
+                         *   much always used, but the bit is always 0 -- is
+                         *   this just always pushed?)
+                         * - R61 : gl_SampleMaskIn and gl_SampleID, used by
+                         *   varying interpolation.
+                         * - R62 : unknown (bit always unset).
+                         */
+                        u32 preload_regs : 8;
+                        /* In units of 8 bytes or 64 bits, since the
+                         * uniform/const port loads 64 bits at a time.
+                         */
+                        u32 uniform_count : 7;
+                        u32 unk4 : 10; // = 2
+                } bifrost2;
+                struct {
+                        u32 unknown2_7;
+                } midgard2;
+        };
+
+        /* zero on bifrost */
+        u32 unknown2_8;
+
+        /* Blending information for the older non-MRT Midgard HW. Check for
+         * MALI_HAS_BLEND_SHADER to decide how to interpret.
+         */
+
+        union {
+                mali_ptr blend_shader;
+                struct mali_blend_equation blend_equation;
+        };
+
+        /* There can be up to 4 blend_meta's. None of them are required for
+         * vertex shaders or the non-MRT case for Midgard (so the blob doesn't
+         * allocate any space).
+         */
+        struct mali_blend_meta blend_meta[];
+
+} __attribute__((packed));
+
+/* This only concerns hardware jobs */
+
+/* Possible values for job_descriptor_size */
+
+#define MALI_JOB_32 0
+#define MALI_JOB_64 1
+
+struct mali_job_descriptor_header {
+        u32 exception_status;
+        u32 first_incomplete_task;
+        u64 fault_pointer;
+        u8 job_descriptor_size : 1;
+        enum mali_job_type job_type : 7;
+        u8 job_barrier : 1;
+        u8 unknown_flags : 7;
+        u16 job_index;
+        u16 job_dependency_index_1;
+        u16 job_dependency_index_2;
+
+        union {
+                u64 next_job_64;
+                u32 next_job_32;
+        };
+} __attribute__((packed));
+
+struct mali_payload_set_value {
+        u64 out;
+        u64 unknown;
+} __attribute__((packed));
+
+/* Special attributes have a fixed index */
+#define MALI_SPECIAL_ATTRIBUTE_BASE 16
+#define MALI_VERTEX_ID   (MALI_SPECIAL_ATTRIBUTE_BASE + 0)
+#define MALI_INSTANCE_ID (MALI_SPECIAL_ATTRIBUTE_BASE + 1)
+
+struct mali_attr {
+        mali_ptr elements;
+        u32 stride;
+        u32 size;
+} __attribute__((packed));
+
+/* TODO: I'm pretty sure this isn't really right in the presence of more
+ * complicated metadata, like matrices or varyings */
+
+enum mali_attr_type {
+        MALI_ATYPE_PACKED = 1,
+        MALI_ATYPE_UNK1 = 1,
+        MALI_ATYPE_BYTE = 3,
+        MALI_ATYPE_SHORT = 4,
+        MALI_ATYPE_INT = 5,
+        MALI_ATYPE_GPVARYING = 6,
+        MALI_ATYPE_FLOAT = 7,
+};
+
+struct mali_attr_meta {
+        /* Vertex buffer index */
+        u8 index;
+
+        u64 unknown1 : 14;
+
+        /* Part of the type specifier, anyway:
+         * 1: packed (with other encoding weirdness)
+         * 3: byte
+         * 4: short
+         * 5: int
+         * 6: used for float gl_Position varying?
+         * 7: half, float, packed
+         */
+
+        unsigned type : 3;
+
+        /* After MALI_POSITIVE, 4 for vec4, 1 for scalar, etc */
+        unsigned nr_components : 2;
+
+        /* Somewhat correlated to the opposite of not_normalised, or the opposite of is_half_float? */
+        unsigned unknown2 : 1;
+
+        /* If the type is a signed integer, is_int_signed is set. If the type
+         * is a half-float, it's also set. Otherwise, it is clear. */
+
+        unsigned is_int_signed : 1;
+
+        /* if `normalized` passed to VertexAttribPointer is clear */
+        unsigned not_normalised : 1;
+
+        /* Always observed to be zero at the moment */
+        unsigned unknown3 : 2;
+
+        /* When packing multiple attributes in a buffer, offset addresses by this value */
+        uint32_t src_offset;
+} __attribute__((packed));
+
+enum mali_fbd_type {
+        MALI_SFBD = 0,
+        MALI_MFBD = 1,
+};
+
+#define FBD_TYPE (1)
+#define FBD_MASK (~0x3f)
+
+struct mali_uniform_buffer_meta {
+        /* This is actually the size minus 1 (MALI_POSITIVE), in units of 16
+         * bytes. This gives a maximum of 2^14 bytes, which just so happens to
+         * be the GL minimum-maximum for GL_MAX_UNIFORM_BLOCK_SIZE.
+         */
+        u64 size : 10;
+
+        /* This is missing the bottom 2 bits and top 8 bits. The top 8 bits
+         * should be 0 for userspace pointers, according to
+         * https://lwn.net/Articles/718895/. By reusing these bits, we can make
+         * each entry in the table only 64 bits.
+         */
+        mali_ptr ptr : 64 - 10;
+};
+
+/* On Bifrost, these fields are the same between the vertex and tiler payloads.
+ * They also seem to be the same between Bifrost and Midgard. They're shared in
+ * fused payloads.
+ */
+
+/* Applies to unknown_draw */
+#define MALI_DRAW_INDEXED_UINT8  (0x10)
+#define MALI_DRAW_INDEXED_UINT16 (0x20)
+#define MALI_DRAW_INDEXED_UINT32 (0x30)
+
+struct mali_vertex_tiler_prefix {
+        /* This is a dynamic bitfield containing the following things in this order:
+         *
+         * - gl_WorkGroupSize.x
+         * - gl_WorkGroupSize.y
+         * - gl_WorkGroupSize.z
+         * - gl_NumWorkGroups.x
+         * - gl_NumWorkGroups.y
+         * - gl_NumWorkGroups.z
+         *
+         * The number of bits allocated for each number is based on the *_shift
+         * fields below. For example, workgroups_y_shift gives the bit that
+         * gl_NumWorkGroups.y starts at, and workgroups_z_shift gives the bit
+         * that gl_NumWorkGroups.z starts at (and therefore one after the bit
+         * that gl_NumWorkGroups.y ends at). The actual value for each gl_*
+         * value is one more than the stored value, since if any of the values
+         * are zero, then there would be no invocations (and hence no job). If
+         * there were 0 bits allocated to a given field, then it must be zero,
+         * and hence the real value is one.
+         *
+         * Vertex jobs reuse the same job dispatch mechanism as compute jobs,
+         * effectively doing glDispatchCompute(1, vertex_count, instance_count)
+         * where vertex count is the number of vertices.
+         */
+        u32 invocation_count;
+
+        u32 size_y_shift : 5;
+        u32 size_z_shift : 5;
+        u32 workgroups_x_shift : 6;
+        u32 workgroups_y_shift : 6;
+        u32 workgroups_z_shift : 6;
+        /* This is max(workgroups_x_shift, 2) in all the cases I've seen. */
+        u32 workgroups_x_shift_2 : 4;
+
+        u32 draw_mode : 4;
+        u32 unknown_draw : 22;
+
+        /* This is the the same as workgroups_x_shift_2 in compute shaders, but
+         * always 5 for vertex jobs and 6 for tiler jobs. I suspect this has
+         * something to do with how many quads get put in the same execution
+         * engine, which is a balance (you don't want to starve the engine, but
+         * you also want to distribute work evenly).
+         */
+        u32 workgroups_x_shift_3 : 6;
+
+
+        /* Negative of draw_start for TILER jobs from what I've seen */
+        int32_t negative_start;
+        u32 zero1;
+
+        /* Like many other strictly nonzero quantities, index_count is
+         * subtracted by one. For an indexed cube, this is equal to 35 = 6
+         * faces * 2 triangles/per face * 3 vertices/per triangle - 1. For
+         * non-indexed draws, equal to vertex_count. */
+
+        u32 index_count;
+
+        /* No hidden structure; literally just a pointer to an array of
+         * uint32_t indices. Thanks, guys, for not making my life insane for
+         * once! NULL for non-indexed draws. */
+
+        uintptr_t indices;
+} __attribute__((packed));
+
+struct bifrost_vertex_only {
+        u32 unk2; /* =0x2 */
+
+        u32 zero0;
+
+        u64 zero1;
+} __attribute__((packed));
+
+struct bifrost_tiler_heap_meta {
+        u32 zero;
+        u32 heap_size;
+        /* note: these are just guesses! */
+        mali_ptr tiler_heap_start;
+        mali_ptr tiler_heap_free;
+        mali_ptr tiler_heap_end;
+
+        /* hierarchy weights? but they're still 0 after the job has run... */
+        u32 zeros[12];
+} __attribute__((packed));
+
+struct bifrost_tiler_meta {
+        u64 zero0;
+        u32 unk; // = 0xf0
+        u16 width;
+        u16 height;
+        u64 zero1;
+        mali_ptr tiler_heap_meta;
+        /* TODO what is this used for? */
+        u64 zeros[20];
+} __attribute__((packed));
+
+struct bifrost_tiler_only {
+        /* 0x20 */
+        float line_width;
+        u32 zero0;
+
+        mali_ptr tiler_meta;
+
+        u64 zero1, zero2, zero3, zero4, zero5, zero6;
+
+        u32 gl_enables;
+        u32 zero7;
+        u64 zero8;
+} __attribute__((packed));
+
+struct bifrost_scratchpad {
+        u32 zero;
+        u32 flags; // = 0x1f
+        /* This is a pointer to a CPU-inaccessible buffer, 16 pages, allocated
+         * during startup. It seems to serve the same purpose as the
+         * gpu_scratchpad in the SFBD for Midgard, although it's slightly
+         * larger.
+         */
+        mali_ptr gpu_scratchpad;
+} __attribute__((packed));
+
+struct mali_vertex_tiler_postfix {
+        /* Zero for vertex jobs. Pointer to the position (gl_Position) varying
+         * output from the vertex shader for tiler jobs.
+         */
+
+        uintptr_t position_varying;
+
+        /* An array of mali_uniform_buffer_meta's. The size is given by the
+         * shader_meta.
+         */
+        uintptr_t uniform_buffers;
+
+        /* For reasons I don't quite understand this is a pointer to a pointer.
+         * That second pointer points to the actual texture descriptor. */
+        uintptr_t texture_trampoline;
+
+        /* For OpenGL, from what I've seen, this is intimately connected to
+         * texture_meta. cwabbott says this is not the case under Vulkan, hence
+         * why this field is seperate (Midgard is Vulkan capable) */
+        uintptr_t sampler_descriptor;
+
+        uintptr_t uniforms;
+        u8 flags : 4;
+uintptr_t _shader_upper :
+        MALI_SHORT_PTR_BITS - 4; /* struct shader_meta */
+        uintptr_t attributes; /* struct attribute_buffer[] */
+        uintptr_t attribute_meta; /* attribute_meta[] */
+        uintptr_t varyings; /* struct attr */
+        uintptr_t varying_meta; /* pointer */
+        uintptr_t viewport;
+        uintptr_t zero6;
+
+        /* Note: on Bifrost, this isn't actually the FBD. It points to
+         * bifrost_scratchpad instead. However, it does point to the same thing
+         * in vertex and tiler jobs.
+         */
+        mali_ptr framebuffer;
+
+#if UINTPTR_MAX == 0xffffffffffffffff /* 64-bit */
+#ifndef T8XX
+        /* most likely padding to make this a multiple of 64 bytes */
+        u64 zero7;
+#endif
+#endif
+} __attribute__((packed));
+
+struct midgard_payload_vertex_tiler {
+#ifdef T6XX
+        float line_width;
+#endif
+
+        struct mali_vertex_tiler_prefix prefix;
+
+#ifdef T6XX
+        u32 zero3;
+#endif
+        u32 gl_enables; // 0x5
+
+        /* Offset for first vertex in buffer */
+        u32 draw_start;
+
+#ifdef T6XX
+        u32 zero5;
+#else
+        u64 zero5;
+#endif
+
+        struct mali_vertex_tiler_postfix postfix;
+
+#ifdef T8XX
+        float line_width;
+#endif
+} __attribute__((packed));
+
+struct bifrost_payload_vertex {
+        struct mali_vertex_tiler_prefix prefix;
+        struct bifrost_vertex_only vertex;
+        struct mali_vertex_tiler_postfix postfix;
+} __attribute__((packed));
+
+struct bifrost_payload_tiler {
+        struct mali_vertex_tiler_prefix prefix;
+        struct bifrost_tiler_only tiler;
+        struct mali_vertex_tiler_postfix postfix;
+} __attribute__((packed));
+
+struct bifrost_payload_fused {
+        struct mali_vertex_tiler_prefix prefix;
+        struct bifrost_tiler_only tiler;
+        struct mali_vertex_tiler_postfix tiler_postfix;
+        struct bifrost_vertex_only vertex;
+        struct mali_vertex_tiler_postfix vertex_postfix;
+} __attribute__((packed));
+
+/* Pointed to from texture_trampoline, mostly unknown still, haven't
+ * managed to replay successfully */
+
+/* Purposeful off-by-one in width, height fields. For example, a (64, 64)
+ * texture is stored as (63, 63) in these fields. This adjusts for that.
+ * There's an identical pattern in the framebuffer descriptor. Even vertex
+ * count fields work this way, hence the generic name -- integral fields that
+ * are strictly positive generally need this adjustment. */
+
+#define MALI_POSITIVE(dim) (dim - 1)
+
+/* Opposite of MALI_POSITIVE, found in the depth_units field */
+
+#define MALI_NEGATIVE(dim) (dim + 1)
+
+/* Used with channel swizzling */
+enum mali_channel {
+        MALI_CHANNEL_RED = 0,
+        MALI_CHANNEL_GREEN = 1,
+        MALI_CHANNEL_BLUE = 2,
+        MALI_CHANNEL_ALPHA = 3,
+        MALI_CHANNEL_ZERO = 4,
+        MALI_CHANNEL_ONE = 5,
+        MALI_CHANNEL_RESERVED_0 = 6,
+        MALI_CHANNEL_RESERVED_1 = 7,
+};
+
+/* Used with wrapping. Incomplete (this is a 4-bit field...) */
+
+enum mali_wrap_mode {
+        MALI_WRAP_REPEAT = 0x8,
+        MALI_WRAP_CLAMP_TO_EDGE = 0x9,
+        MALI_WRAP_CLAMP_TO_BORDER = 0xB,
+        MALI_WRAP_MIRRORED_REPEAT = 0xC
+};
+
+/* 8192x8192 */
+#define MAX_MIP_LEVELS (13)
+
+/* Cubemap bloats everything up */
+#define MAX_FACES (6)
+
+/* Corresponds to the type passed to glTexImage2D and so forth */
+
+struct mali_texture_format {
+        unsigned bottom : 8;
+        unsigned unk1 : 4;
+
+        /*
+         * 0: ushort_5_6_5
+         * 2: ushort_4_4_4_4
+         * 3: u8
+         * 4: u16
+         * 5: u32
+         * 7: float
+         */
+
+        unsigned component_size : 3;
+
+        unsigned nr_channels : 2;
+
+        /*
+         * 2: ushort_5_5_5_1, ushort_5_6_5
+         * 3: snorm
+         * 4: unsigned int
+         * 5: (unsigned) int / full-float
+         * 6: signed int / half-float
+         * 7: maybe also snorm related
+         */
+
+        unsigned typeA : 3;
+
+        unsigned usage1 : 3;
+        unsigned is_not_cubemap : 1;
+        unsigned usage2 : 8;
+} __attribute__((packed));
+
+struct mali_texture_descriptor {
+        uint16_t width;
+        uint16_t height;
+        uint16_t depth;
+
+        uint16_t unknown1;
+
+        struct mali_texture_format format;
+
+        uint16_t unknown3;
+
+        /* One for non-mipmapped, zero for mipmapped */
+        uint8_t unknown3A;
+
+        /* Zero for non-mipmapped, (number of levels - 1) for mipmapped */
+        uint8_t nr_mipmap_levels;
+
+        /* Swizzling is a single 32-bit word, broken up here for convenience.
+         * Here, swizzling refers to the ES 3.0 texture parameters for channel
+         * level swizzling, not the internal pixel-level swizzling which is
+         * below OpenGL's reach */
+
+        enum mali_channel swizzle_r : 3;
+        enum mali_channel swizzle_g : 3;
+        enum mali_channel swizzle_b : 3;
+        enum mali_channel swizzle_a : 3;
+        unsigned swizzle_zero       : 20;
+
+        uint32_t unknown5;
+        uint32_t unknown6;
+        uint32_t unknown7;
+
+        mali_ptr swizzled_bitmaps[MAX_MIP_LEVELS * MAX_FACES];
+} __attribute__((packed));
+
+/* Used as part of filter_mode */
+
+#define MALI_GL_LINEAR 0
+#define MALI_GL_NEAREST 1
+#define MALI_GL_MIP_LINEAR (0x18)
+
+/* Used to construct low bits of filter_mode */
+
+#define MALI_GL_TEX_MAG(mode) (((mode) & 1) << 0)
+#define MALI_GL_TEX_MIN(mode) (((mode) & 1) << 1)
+
+#define MALI_GL_TEX_MAG_MASK (1)
+#define MALI_GL_TEX_MIN_MASK (2)
+
+#define MALI_FILTER_NAME(filter) (filter ? "MALI_GL_NEAREST" : "MALI_GL_LINEAR")
+
+/* Used for lod encoding. Thanks @urjaman for pointing out these routines can
+ * be cleaned up a lot. */
+
+#define DECODE_FIXED_16(x) ((float) (x / 256.0))
+
+static inline uint16_t
+FIXED_16(float x)
+{
+        /* Clamp inputs, accounting for float error */
+        float max_lod = (32.0 - (1.0 / 512.0));
+
+        x = ((x > max_lod) ? max_lod : ((x < 0.0) ? 0.0 : x));
+
+        return (int) (x * 256.0);
+}
+
+struct mali_sampler_descriptor {
+        uint32_t filter_mode;
+
+        /* Fixed point. Upper 8-bits is before the decimal point, although it
+         * caps [0-31]. Lower 8-bits is after the decimal point: int(round(x *
+         * 256)) */
+
+        uint16_t min_lod;
+        uint16_t max_lod;
+
+        /* All one word in reality, but packed a bit */
+
+        enum mali_wrap_mode wrap_s : 4;
+        enum mali_wrap_mode wrap_t : 4;
+        enum mali_wrap_mode wrap_r : 4;
+        enum mali_alt_func compare_func : 3;
+
+        /* A single set bit of unknown, ha! */
+        unsigned unknown2 : 1;
+
+        unsigned zero : 16;
+
+        uint32_t zero2;
+        float border_color[4];
+} __attribute__((packed));
+
+/* TODO: What are the floats? Apparently always { -inf, -inf, inf, inf },
+ * unless the scissor test is enabled.
+ *
+ * viewport0/viewport1 form the arguments to glViewport. viewport1 is modified
+ * by MALI_POSITIVE; viewport0 is as-is.
+ */
+
+struct mali_viewport {
+        float floats[4];
+
+        float depth_range_n;
+        float depth_range_f;
+
+        u16 viewport0[2];
+        u16 viewport1[2];
+} __attribute__((packed));
+
+/* TODO: Varying meta is symmetrical with attr_meta, but there is some
+ * weirdness associated. Figure it out. */
+
+struct mali_unknown6 {
+        u64 unknown0;
+        u64 unknown1;
+};
+
+/* From presentations, 16x16 tiles externally. Use shift for fast computation
+ * of tile numbers. */
+
+#define MALI_TILE_SHIFT 4
+#define MALI_TILE_LENGTH (1 << MALI_TILE_SHIFT)
+
+/* Tile coordinates are stored as a compact u32, as only 12 bits are needed to
+ * each component. Notice that this provides a theoretical upper bound of (1 <<
+ * 12) = 4096 tiles in each direction, addressing a maximum framebuffer of size
+ * 65536x65536. Multiplying that together, times another four given that Mali
+ * framebuffers are 32-bit ARGB8888, means that this upper bound would take 16
+ * gigabytes of RAM just to store the uncompressed framebuffer itself, let
+ * alone rendering in real-time to such a buffer.
+ *
+ * Nice job, guys.*/
+
+/* From mali_kbase_10969_workaround.c */
+#define MALI_X_COORD_MASK 0x00000FFF
+#define MALI_Y_COORD_MASK 0x0FFF0000
+
+/* Extract parts of a tile coordinate */
+
+#define MALI_TILE_COORD_X(coord) ((coord) & MALI_X_COORD_MASK)
+#define MALI_TILE_COORD_Y(coord) (((coord) & MALI_Y_COORD_MASK) >> 16)
+#define MALI_TILE_COORD_FLAGS(coord) ((coord) & ~(MALI_X_COORD_MASK | MALI_Y_COORD_MASK))
+
+/* No known flags yet, but just in case...? */
+
+#define MALI_TILE_NO_FLAG (0)
+
+/* Helpers to generate tile coordinates based on the boundary coordinates in
+ * screen space. So, with the bounds (0, 0) to (128, 128) for the screen, these
+ * functions would convert it to the bounding tiles (0, 0) to (7, 7).
+ * Intentional "off-by-one"; finding the tile number is a form of fencepost
+ * problem. */
+
+#define MALI_MAKE_TILE_COORDS(X, Y) ((X) | ((Y) << 16))
+#define MALI_BOUND_TO_TILE(B, bias) ((B - bias) >> MALI_TILE_SHIFT)
+#define MALI_COORDINATE_TO_TILE(W, H, bias) MALI_MAKE_TILE_COORDS(MALI_BOUND_TO_TILE(W, bias), MALI_BOUND_TO_TILE(H, bias))
+#define MALI_COORDINATE_TO_TILE_MIN(W, H) MALI_COORDINATE_TO_TILE(W, H, 0)
+#define MALI_COORDINATE_TO_TILE_MAX(W, H) MALI_COORDINATE_TO_TILE(W, H, 1)
+
+struct mali_payload_fragment {
+        u32 min_tile_coord;
+        u32 max_tile_coord;
+        mali_ptr framebuffer;
+} __attribute__((packed));
+
+/* (Single?) Framebuffer Descriptor */
+
+/* Flags apply to format. With just MSAA_A and MSAA_B, the framebuffer is
+ * configured for 4x. With MSAA_8, it is configured for 8x. */
+
+#define MALI_FRAMEBUFFER_MSAA_8 (1 << 3)
+#define MALI_FRAMEBUFFER_MSAA_A (1 << 4)
+#define MALI_FRAMEBUFFER_MSAA_B (1 << 23)
+
+/* Fast/slow based on whether all three buffers are cleared at once */
+
+#define MALI_CLEAR_FAST         (1 << 18)
+#define MALI_CLEAR_SLOW         (1 << 28)
+#define MALI_CLEAR_SLOW_STENCIL (1 << 31)
+
+struct mali_single_framebuffer {
+        u32 unknown1;
+        u32 unknown2;
+        u64 unknown_address_0;
+        u64 zero1;
+        u64 zero0;
+
+        /* Exact format is ironically not known, since EGL is finnicky with the
+         * blob. MSAA, colourspace, etc are configured here. */
+
+        u32 format;
+
+        u32 clear_flags;
+        u32 zero2;
+
+        /* Purposeful off-by-one in these fields should be accounted for by the
+         * MALI_DIMENSION macro */
+
+        u16 width;
+        u16 height;
+
+        u32 zero3[8];
+
+        /* By default, the framebuffer is upside down from OpenGL's
+         * perspective. Set framebuffer to the end and negate the stride to
+         * flip in the Y direction */
+
+        mali_ptr framebuffer;
+        int32_t stride;
+
+        u32 zero4;
+
+        /* Depth and stencil buffers are interleaved, it appears, as they are
+         * set to the same address in captures. Both fields set to zero if the
+         * buffer is not being cleared. Depending on GL_ENABLE magic, you might
+         * get a zero enable despite the buffer being present; that still is
+         * disabled. */
+
+        mali_ptr depth_buffer; // not SAME_VA
+        u64 depth_buffer_enable;
+
+        mali_ptr stencil_buffer; // not SAME_VA
+        u64 stencil_buffer_enable;
+
+        u32 clear_color_1; // RGBA8888 from glClear, actually used by hardware
+        u32 clear_color_2; // always equal, but unclear function?
+        u32 clear_color_3; // always equal, but unclear function?
+        u32 clear_color_4; // always equal, but unclear function?
+
+        /* Set to zero if not cleared */
+
+        float clear_depth_1; // float32, ditto
+        float clear_depth_2; // float32, ditto
+        float clear_depth_3; // float32, ditto
+        float clear_depth_4; // float32, ditto
+
+        u32 clear_stencil; // Exactly as it appears in OpenGL
+
+        u32 zero6[7];
+
+        /* Very weird format, see generation code in trans_builder.c */
+        u32 resolution_check;
+
+        u32 tiler_flags;
+
+        u64 unknown_address_1; /* Pointing towards... a zero buffer? */
+        u64 unknown_address_2;
+
+        /* See mali_kbase_replay.c */
+        u64 tiler_heap_free;
+        u64 tiler_heap_end;
+
+        /* More below this, maybe */
+} __attribute__((packed));
+
+/* Format bits for the render target */
+
+#define MALI_MFBD_FORMAT_AFBC 	  (1 << 10)
+#define MALI_MFBD_FORMAT_MSAA 	  (1 << 12)
+#define MALI_MFBD_FORMAT_NO_ALPHA (1 << 25)
+
+struct bifrost_render_target {
+        u32 unk1; // = 0x4000000
+        u32 format;
+
+        u64 zero1;
+
+        union {
+                struct {
+                        /* Stuff related to ARM Framebuffer Compression. When AFBC is enabled,
+                         * there is an extra metadata buffer that contains 16 bytes per tile.
+                         * The framebuffer needs to be the same size as before, since we don't
+                         * know ahead of time how much space it will take up. The
+                         * framebuffer_stride is set to 0, since the data isn't stored linearly
+                         * anymore.
+                         */
+
+                        mali_ptr metadata;
+                        u32 stride; // stride in units of tiles
+                        u32 unk; // = 0x20000
+                } afbc;
+
+                struct {
+                        /* Heck if I know */
+                        u64 unk;
+                        mali_ptr pointer;
+                } chunknown;
+        };
+
+        mali_ptr framebuffer;
+
+        u32 zero2 : 4;
+        u32 framebuffer_stride : 28; // in units of bytes
+        u32 zero3;
+
+        u32 clear_color_1; // RGBA8888 from glClear, actually used by hardware
+        u32 clear_color_2; // always equal, but unclear function?
+        u32 clear_color_3; // always equal, but unclear function?
+        u32 clear_color_4; // always equal, but unclear function?
+} __attribute__((packed));
+
+/* An optional part of bifrost_framebuffer. It comes between the main structure
+ * and the array of render targets. It must be included if any of these are
+ * enabled:
+ *
+ * - Transaction Elimination
+ * - Depth/stencil
+ * - TODO: Anything else?
+ */
+
+struct bifrost_fb_extra {
+        mali_ptr checksum;
+        /* Each tile has an 8 byte checksum, so the stride is "width in tiles * 8" */
+        u32 checksum_stride;
+
+        u32 unk;
+
+        union {
+                /* Note: AFBC is only allowed for 24/8 combined depth/stencil. */
+                struct {
+                        mali_ptr depth_stencil_afbc_metadata;
+                        u32 depth_stencil_afbc_stride; // in units of tiles
+                        u32 zero1;
+
+                        mali_ptr depth_stencil;
+
+                        u64 padding;
+                } ds_afbc;
+
+                struct {
+                        /* Depth becomes depth/stencil in case of combined D/S */
+                        mali_ptr depth;
+                        u32 depth_stride_zero : 4;
+                        u32 depth_stride : 28;
+                        u32 zero1;
+
+                        mali_ptr stencil;
+                        u32 stencil_stride_zero : 4;
+                        u32 stencil_stride : 28;
+                        u32 zero2;
+                } ds_linear;
+        };
+
+
+        u64 zero3, zero4;
+} __attribute__((packed));
+
+/* flags for unk3 */
+#define MALI_MFBD_EXTRA (1 << 13)
+
+struct bifrost_framebuffer {
+        u32 unk0; // = 0x10
+        u32 zero1;
+        u64 zero2;
+        /* 0x10 */
+        mali_ptr sample_locations;
+        mali_ptr unknown1;
+        /* 0x20 */
+        u16 width1, height1;
+        u32 zero3;
+        u16 width2, height2;
+        u32 unk1 : 19; // = 0x01000
+        u32 rt_count_1 : 2; // off-by-one (use MALI_POSITIVE)
+        u32 unk2 : 3; // = 0
+        u32 rt_count_2 : 3; // no off-by-one
+        u32 zero4 : 5;
+        /* 0x30 */
+        u32 clear_stencil : 8;
+        u32 unk3 : 24; // = 0x100
+        float clear_depth;
+        mali_ptr tiler_meta;
+        /* 0x40 */
+        u64 zero5, zero6, zero7, zero8, zero9, zero10, zero11, zero12;
+
+        /* optional: struct bifrost_fb_extra extra */
+        /* struct bifrost_render_target rts[] */
+} __attribute__((packed));
+
+#endif /* __PANFROST_JOB_H__ */
diff --git a/src/gallium/drivers/panfrost/pan_blend_shaders.h b/src/gallium/drivers/panfrost/pan_blend_shaders.h
index 3d0f42f..1a91477 100644
--- a/src/gallium/drivers/panfrost/pan_blend_shaders.h
+++ b/src/gallium/drivers/panfrost/pan_blend_shaders.h
@@ -27,7 +27,7 @@
 
 #include "pipe/p_state.h"
 #include "pipe/p_defines.h"
-#include <mali-job.h>
+#include <panfrost-job.h>
 #include "pan_context.h"
 
 void
diff --git a/src/gallium/drivers/panfrost/pan_blending.h b/src/gallium/drivers/panfrost/pan_blending.h
index ac773fb..926b41e 100644
--- a/src/gallium/drivers/panfrost/pan_blending.h
+++ b/src/gallium/drivers/panfrost/pan_blending.h
@@ -27,7 +27,7 @@
 
 #include "pipe/p_state.h"
 #include "pipe/p_defines.h"
-#include <mali-job.h>
+#include <panfrost-job.h>
 
 bool panfrost_make_fixed_blend_mode(const struct pipe_rt_blend_state *blend, struct mali_blend_equation *out, unsigned colormask, const struct pipe_blend_color *blend_color);
 
diff --git a/src/gallium/drivers/panfrost/pan_nondrm.c b/src/gallium/drivers/panfrost/pan_nondrm.c
index d128686..099ac29 100644
--- a/src/gallium/drivers/panfrost/pan_nondrm.c
+++ b/src/gallium/drivers/panfrost/pan_nondrm.c
@@ -29,7 +29,7 @@
 #include <sys/mman.h>
 #include <assert.h>
 
-#include <mali-ioctl.h>
+#include <panfrost-ioctl.h>
 #include "pan_nondrm.h"
 
 /* From the kernel module */
diff --git a/src/gallium/drivers/panfrost/pan_nondrm.h b/src/gallium/drivers/panfrost/pan_nondrm.h
index 0a369d0..ac72a67 100644
--- a/src/gallium/drivers/panfrost/pan_nondrm.h
+++ b/src/gallium/drivers/panfrost/pan_nondrm.h
@@ -28,8 +28,8 @@
 #include <unistd.h>
 #include <sys/mman.h>
 #include <stdbool.h>
-#include <mali-ioctl.h>
-#include <mali-job.h>
+#include <panfrost-ioctl.h>
+#include <panfrost-job.h>
 #include <linux/ioctl.h>
 #include "pan_slowfb.h"
 
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
index 07f0d38..c2e91a2 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
@@ -22,8 +22,8 @@
  
  */
 
-#include <mali-ioctl.h>
-#include <mali-job.h>
+#include <panfrost-ioctl.h>
+#include <panfrost-job.h>
 #include <stdio.h>
 #include <memory.h>
 #include "panwrap.h"
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h
index e758cbd..8bd7d42 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h
@@ -25,8 +25,8 @@
 #ifndef PANWRAP_DECODER_H
 #define PANWRAP_DECODER_H
 
-#include <mali-ioctl.h>
-#include <mali-job.h>
+#include <panfrost-ioctl.h>
+#include <panfrost-job.h>
 #include "panwrap.h"
 
 int panwrap_replay_jc(mali_ptr jc_gpu_va, bool bifrost);
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.c b/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.c
index e19b88a..7a099a1 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.c
@@ -28,7 +28,7 @@
 #include <stdarg.h>
 #include <memory.h>
 
-#include <mali-ioctl.h>
+#include <panfrost-ioctl.h>
 #include "panwrap.h"
 #include "panwrap-mmap.h"
 #ifdef HAVE_LINUX_MMAN_H
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.h b/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.h
index 88410f3..f34f4ce 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.h
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-mmap.h
@@ -25,7 +25,7 @@
 #ifndef __MMAP_TRACE_H__
 #define __MMAP_TRACE_H__
 
-#include <mali-ioctl.h>
+#include <panfrost-ioctl.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include "panwrap.h"
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-syscall.c b/src/gallium/drivers/panfrost/panwrap/panwrap-syscall.c
index 29875fa..4d3f2b4 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-syscall.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-syscall.c
@@ -41,7 +41,7 @@
 #include <ctype.h>
 
 #include <assert.h>
-#include <mali-ioctl.h>
+#include <panfrost-ioctl.h>
 #include "panwrap.h"
 
 static pthread_mutex_t l;
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-util.h b/src/gallium/drivers/panfrost/panwrap/panwrap-util.h
index fbbb5f5..e04b6ee 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-util.h
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-util.h
@@ -29,7 +29,7 @@
 #ifndef __PANLOADER_UTIL_H__
 #define __PANLOADER_UTIL_H__
 
-#include <mali-int.h>
+#include <panfrost-int.h>
 #include "util/macros.h"
 
 #define __PASTE_TOKENS(a, b) a ## b
-- 
2.7.4

