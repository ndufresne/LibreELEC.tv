From fa9b9f11a657cc5b75667aec33738090b3d2ead8 Mon Sep 17 00:00:00 2001
From: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date: Tue, 4 Dec 2018 18:30:02 +0100
Subject: [PATCH 137/151] panfrost: remove ad-hoc framebuffer remnants

Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
---
 src/gallium/drivers/panfrost/pan_context.c | 138 +++++++++--------------------
 src/gallium/drivers/panfrost/pan_context.h |   3 -
 src/gallium/drivers/panfrost/pan_screen.c  |   3 +
 3 files changed, 43 insertions(+), 101 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 12855b9..fe50d19 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -331,13 +331,7 @@ panfrost_new_frag_framebuffer(struct panfrost_context *ctx)
         mali_ptr framebuffer = ((struct panfrost_resource *) ctx->pipe_framebuffer.cbufs[0]->texture)->gpu[0];
         int stride;
 
-        /* The default is upside down from OpenGL's perspective. Plus, for scanout we supply our own framebuffer / stride */
-        if (panfrost_is_scanout(ctx)) {
-                stride = ctx->scanout_stride;
-
-                framebuffer += stride * (ctx->pipe_framebuffer.height - 1);
-                stride = -stride;
-        } else if (ctx->pipe_framebuffer.nr_cbufs > 0) {
+        if (ctx->pipe_framebuffer.nr_cbufs > 0) {
                 stride = util_format_get_stride(ctx->pipe_framebuffer.cbufs[0]->format, ctx->pipe_framebuffer.width);
         } else {
                 /* Depth-only framebuffer -> dummy RT */
@@ -345,6 +339,12 @@ panfrost_new_frag_framebuffer(struct panfrost_context *ctx)
                 stride = 0;
         }
 
+        /* The default is upside down from OpenGL's perspective. */
+        if (panfrost_is_scanout(ctx)) {
+                framebuffer += stride * (ctx->pipe_framebuffer.height - 1);
+                stride = -stride;
+        }
+
 #ifdef SFBD
         struct mali_single_framebuffer fb = panfrost_emit_fbd(ctx);
 
@@ -938,6 +938,7 @@ panfrost_fragment_job(struct panfrost_context *ctx)
 
         if (ctx->pipe_framebuffer.nr_cbufs == 1) {
                 struct panfrost_resource *rsrc = (struct panfrost_resource *) ctx->pipe_framebuffer.cbufs[0]->texture;
+                int stride = util_format_get_stride(rsrc->base.format, rsrc->base.width0);
 
                 if (rsrc->has_checksum) {
                         //ctx->fragment_fbd.unk3 |= 0xa00000;
@@ -945,7 +946,7 @@ panfrost_fragment_job(struct panfrost_context *ctx)
                         ctx->fragment_fbd.unk3 |= MALI_MFBD_EXTRA;
                         ctx->fragment_extra.unk = 0x420;
                         ctx->fragment_extra.checksum_stride = rsrc->checksum_stride;
-                        ctx->fragment_extra.checksum = rsrc->gpu[0] + (ctx->scanout_stride) * rsrc->base.height0;
+                        ctx->fragment_extra.checksum = rsrc->gpu[0] + stride * rsrc->base.height0;
                 }
         }
 
@@ -2184,45 +2185,40 @@ panfrost_resource_create_front(struct pipe_screen *screen,
         if (template->depth0) sz *= template->depth0;
 
         if ((template->bind & PIPE_BIND_RENDER_TARGET) || (template->bind & PIPE_BIND_DEPTH_STENCIL)) {
-                if (template->bind & PIPE_BIND_DISPLAY_TARGET) {
-                        /* TODO: Allocate display target surface */
-                        so->cpu[0] = pscreen->any_context->framebuffer.cpu;
-                        so->gpu[0] = pscreen->any_context->framebuffer.gpu;
+                if (template->bind & PIPE_BIND_DISPLAY_TARGET ||
+                    template->bind & PIPE_BIND_SCANOUT) {
+                        struct pipe_resource scanout_templat = *template;
+                        struct renderonly_scanout *scanout;
+                        struct winsys_handle handle;
+
+                        /* TODO: align width0 and height0? */
+
+                        scanout = renderonly_scanout_for_resource(&scanout_templat,
+                                                                  pscreen->ro, &handle);
+                        if (!scanout)
+                                return NULL;
+
+                        assert(handle.type == WINSYS_HANDLE_TYPE_FD);
+                        /* TODO: handle modifiers? */
+                        so = pan_resource(screen->resource_from_handle(screen, template,
+                                                                         &handle,
+                                                                         PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE));
+                        close(handle.handle);
+                        if (!so)
+                                return NULL;
+
+                        so->scanout = scanout;
                 } else {
                         /* TODO: Mipmapped RTs */
                         //assert(template->last_level == 0);
 
-                        if (template->bind & PIPE_BIND_SCANOUT) {
-                                struct pipe_resource scanout_templat = *template;
-                                struct renderonly_scanout *scanout;
-                                struct winsys_handle handle;
-
-                                /* TODO: align width0 and height0? */
-
-                                scanout = renderonly_scanout_for_resource(&scanout_templat,
-                                                                          pscreen->ro, &handle);
-                                if (!scanout)
-                                        return NULL;
-
-                                assert(handle.type == WINSYS_HANDLE_TYPE_FD);
-                                /* TODO: handle modifiers? */
-                                so = pan_resource(screen->resource_from_handle(screen, template,
-                                                                                 &handle,
-                                                                                 PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE));
-                                close(handle.handle);
-                                if (!so)
-                                        return NULL;
-
-                                so->scanout = scanout;
-                        } else {
-                                /* Allocate the framebuffer as its own slab of GPU-accessible memory */
-                                struct panfrost_memory slab;
-                                panfrost_allocate_slab(pscreen->any_context, &slab, (sz / 4096) + 1, false, 0, 0, 0);
-
-                                /* Make the resource out of the slab */
-                                so->cpu[0] = slab.cpu;
-                                so->gpu[0] = slab.gpu;
-                        }
+                        /* Allocate the framebuffer as its own slab of GPU-accessible memory */
+                        struct panfrost_memory slab;
+                        panfrost_allocate_slab(pscreen->any_context, &slab, (sz / 4096) + 1, false, 0, 0, 0);
+
+                        /* Make the resource out of the slab */
+                        so->cpu[0] = slab.cpu;
+                        so->gpu[0] = slab.gpu;
                 }
         } else {
                 /* TODO: For linear resources, allocate straight on the cmdstream for
@@ -2311,7 +2307,7 @@ panfrost_transfer_map(struct pipe_context *pctx,
                 assert(level == 0);
 
                 /* Set the CPU mapping to that of the framebuffer in memory, untiled */
-                rsrc->cpu[level] = ctx->framebuffer.cpu;
+                rsrc->cpu[level] = ((struct panfrost_resource *) ctx->pipe_framebuffer.cbufs[0]->texture)->cpu[0];
 
                 /* Force a flush -- kill the pipeline */
                 panfrost_flush(pctx, NULL, PIPE_FLUSH_END_OF_FRAME);
@@ -2770,56 +2766,6 @@ panfrost_allocate_slab(struct panfrost_context *ctx,
  * */
 
 static void
-panfrost_setup_framebuffer(struct panfrost_context *ctx, int width, int height)
-{
-        struct pipe_context *gallium = (struct pipe_context *) ctx;
-        struct panfrost_screen *screen = panfrost_screen(gallium->screen);
-
-        /* drisw rounds the stride */
-        int rw = 16.0 * (int) ceil((float) width / 16.0);
-
-        size_t framebuffer_sz = rw * height * 4;
-        posix_memalign((void **) &ctx->framebuffer.cpu, CACHE_LINE_SIZE, framebuffer_sz);
-        struct slowfb_info info = slowfb_init((uint8_t *) (ctx->framebuffer.cpu), rw, height);
-
-        /* May not be the same as our original alloc if we're using XShm, etc */
-        ctx->framebuffer.cpu = info.framebuffer;
-
-        struct base_mem_import_user_buffer framebuffer_handle = {
-                .ptr = (uint64_t) (uintptr_t) ctx->framebuffer.cpu,
-                .length = framebuffer_sz
-        };
-
-        union kbase_ioctl_mem_import framebuffer_import = {
-                .in = {
-                        .phandle = (uint64_t) (uintptr_t) &framebuffer_handle,
-                        .type = BASE_MEM_IMPORT_TYPE_USER_BUFFER,
-                        .flags = BASE_MEM_PROT_CPU_RD |
-                                 BASE_MEM_PROT_CPU_WR |
-                                 BASE_MEM_PROT_GPU_RD |
-                                 BASE_MEM_PROT_GPU_WR |
-                                 BASE_MEM_IMPORT_SHARED,
-                }
-        };
-
-        pandev_ioctl(screen->fd, KBASE_IOCTL_MEM_IMPORT, &framebuffer_import);
-
-        /* It feels like this mmap is backwards :p */
-        uint64_t gpu_addr = (uint64_t) mmap(NULL,
-                                            framebuffer_import.out.va_pages * 4096,
-                                            3, 1, screen->fd,
-                                            framebuffer_import.out.gpu_va);
-
-        ctx->framebuffer.gpu = gpu_addr;
-        ctx->framebuffer.size = info.stride * height;
-        ctx->scanout_stride = info.stride;
-
-        ctx->pipe_framebuffer.nr_cbufs = 1;
-        ctx->pipe_framebuffer.width = width;
-        ctx->pipe_framebuffer.height = height;
-}
-
-static void
 panfrost_flush_resource(struct pipe_context *pctx, struct pipe_resource *prsc)
 {
         fprintf(stderr, "TODO %s\n", __func__);
@@ -2839,10 +2785,6 @@ panfrost_setup_hardware(struct panfrost_context *ctx)
 
         pandev_open(screen->fd);
 
-#ifdef USE_SLOWFB
-        panfrost_setup_framebuffer(ctx, 2048, 1280);
-#endif
-
         for (int i = 0; i < ARRAY_SIZE(ctx->cmdstream_rings); ++i)
                 panfrost_allocate_slab(ctx, &ctx->cmdstream_rings[i],
                                        8 * 64 * 8 * 16, true, 0, 0, 0);
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index aa0cd00..96c966c 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -93,7 +93,6 @@ struct panfrost_context {
         struct panfrost_memory scratchpad;
         struct panfrost_memory tiler_heap;
         struct panfrost_memory varying_mem;
-        struct panfrost_memory framebuffer;
         struct panfrost_memory misc_0;
         struct panfrost_memory misc_1;
         struct panfrost_memory depth_stencil_buffer;
@@ -105,8 +104,6 @@ struct panfrost_context {
                 unsigned stencil;
         } last_clear;
 
-        int scanout_stride;
-
         /* Each render job has multiple framebuffer descriptors associated with
          * it, used for various purposes with more or less the same format. The
          * most obvious is the fragment framebuffer descriptor, which carries
diff --git a/src/gallium/drivers/panfrost/pan_screen.c b/src/gallium/drivers/panfrost/pan_screen.c
index 835ebb2..0cf025f 100644
--- a/src/gallium/drivers/panfrost/pan_screen.c
+++ b/src/gallium/drivers/panfrost/pan_screen.c
@@ -38,6 +38,8 @@
 #include "draw/draw_context.h"
 #include "state_tracker/winsys_handle.h"
 
+#include <fcntl.h>
+
 #include "drm_fourcc.h"
 
 #include "pan_screen.h"
@@ -711,6 +713,7 @@ panfrost_resource_from_handle(struct pipe_screen *pscreen,
         ret = pandev_ioctl(screen->fd, KBASE_IOCTL_MEM_IMPORT, &framebuffer_import);
 
         rsc->gpu[0] = mmap(NULL, framebuffer_import.out.va_pages * 4096, PROT_READ | PROT_WRITE, MAP_SHARED, screen->fd, framebuffer_import.out.gpu_va);
+        rsc->cpu[0] = mmap(NULL, framebuffer_import.out.va_pages * 4096, PROT_READ | PROT_WRITE, MAP_SHARED, whandle->handle, 0);
 
         return prsc;
 }
-- 
2.7.4

