From 848eff455e3a19f95c9328fb5b2b903d0263f475 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 12 Dec 2018 21:31:18 +0800
Subject: [PATCH 46/47] drm/lima: support mmap imported buffer

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima_gem.c       |  4 +++
 drivers/gpu/drm/lima/lima_gem_prime.c | 52 +++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/lima/lima_gem_prime.h |  2 ++
 3 files changed, 58 insertions(+)

diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 02bf761..0288496 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -10,6 +10,7 @@
 
 #include "lima_drv.h"
 #include "lima_gem.h"
+#include "lima_gem_prime.h"
 #include "lima_vm.h"
 #include "lima_object.h"
 
@@ -120,6 +121,9 @@ int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma)
 	if (dev == NULL)
 		return -EINVAL;
 
+	if (!lima_gem_prime_mmap(filp, vma))
+		return 0;
+
 	return ttm_bo_mmap(filp, vma, &dev->mman.bdev);
 }
 
diff --git a/drivers/gpu/drm/lima/lima_gem_prime.c b/drivers/gpu/drm/lima/lima_gem_prime.c
index 0e0350c..05c4372 100644
--- a/drivers/gpu/drm/lima/lima_gem_prime.c
+++ b/drivers/gpu/drm/lima/lima_gem_prime.c
@@ -3,6 +3,8 @@
 
 #include <linux/dma-buf.h>
 #include <drm/drm_prime.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_file.h>
 
 #include "lima_device.h"
 #include "lima_object.h"
@@ -45,3 +47,53 @@ struct sg_table *lima_gem_prime_get_sg_table(struct drm_gem_object *obj)
 
 	return drm_prime_pages_to_sg(bo->tbo.ttm->pages, npages);
 }
+
+int lima_gem_prime_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev = priv->minor->dev;
+	struct lima_device *ldev = dev->dev_private;
+	struct ttm_bo_device *bdev = &ldev->mman.bdev;
+	struct drm_gem_object *obj = NULL;
+	struct drm_vma_offset_node *node;
+	int ret;
+
+	drm_vma_offset_lock_lookup(&bdev->vma_manager);
+	node = drm_vma_offset_exact_lookup_locked(&bdev->vma_manager,
+						  vma->vm_pgoff,
+						  vma_pages(vma));
+	if (likely(node)) {
+		struct ttm_buffer_object *tbo =
+			container_of(node, struct ttm_buffer_object, vma_node);
+		struct lima_bo *bo = container_of(tbo, struct lima_bo, tbo);
+		obj = &bo->gem;
+		/*
+		 * When the object is being freed, after it hits 0-refcnt it
+		 * proceeds to tear down the object. In the process it will
+		 * attempt to remove the VMA offset and so acquire this
+		 * mgr->vm_lock.  Therefore if we find an object with a 0-refcnt
+		 * that matches our range, we know it is in the process of being
+		 * destroyed and will be freed as soon as we release the lock -
+		 * so we have to check for the 0-refcnted object and treat it as
+		 * invalid.
+		 */
+		if (!kref_get_unless_zero(&obj->refcount))
+			obj = NULL;
+	}
+	drm_vma_offset_unlock_lookup(&bdev->vma_manager);
+
+	if (!obj)
+		return -EINVAL;
+
+	/* only for buffer imported from other device */
+	if (!obj->import_attach) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = dma_buf_mmap(obj->dma_buf, vma, 0);
+
+out:
+	drm_gem_object_put_unlocked(obj);
+	return ret;
+}
diff --git a/drivers/gpu/drm/lima/lima_gem_prime.h b/drivers/gpu/drm/lima/lima_gem_prime.h
index 6dea7dd..31793e7 100644
--- a/drivers/gpu/drm/lima/lima_gem_prime.h
+++ b/drivers/gpu/drm/lima/lima_gem_prime.h
@@ -10,4 +10,6 @@ struct drm_gem_object *lima_gem_prime_import_sg_table(
 struct sg_table *lima_gem_prime_get_sg_table(struct drm_gem_object *obj);
 struct reservation_object *lima_gem_prime_res_obj(struct drm_gem_object *obj);
 
+int lima_gem_prime_mmap(struct file *filp, struct vm_area_struct *vma);
+
 #endif
-- 
2.7.4

